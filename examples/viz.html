<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Veed Sync</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="stylesheet" href="https://unpkg.com/normalize.css/normalize.css" />
  <link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.5.2/css/all.min.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Barrio&family=Inter:wght@300..900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400..700&display=swap" rel="stylesheet">

  <script type="text/javascript" src="https://unpkg.com/lodash" crossorigin="anonymous"></script>
  <script type="text/javascript" src="https://unpkg.com/butterchurn-presets@3.0.0-beta.4/dist/base.min.js" crossorigin="anonymous"></script>
  <script type="text/javascript" src="https://unpkg.com/butterchurn-presets@3.0.0-beta.4/dist/extra.min.js" crossorigin="anonymous"></script>
  <script type="module">
    import veedSync from '../dist/veed-sync.min.js';
    const _ = (window._ || window.lodash || { throttle: (fn, wait = 100) => {
      let last = 0, t;
      return (...args) => {
        const now = Date.now();
        const remaining = wait - (now - last);
        if (remaining <= 0) { last = now; fn(...args); }
        else { clearTimeout(t); t = setTimeout(() => { last = Date.now(); fn(...args); }, remaining); }
      };
    }});

    let visualizer = null;
    let rendering = false;
    let rafId = 0;
    let audioContext = null;
    let sourceNode = null;
    // Unified tap feeding both destination and analysis/visualizer
    let tapNode = null;
    let internalMethod = localStorage.getItem('internalMethod') || 'auto'; // auto | tab | element
    let tabStream = null;
    let tabCaptureStarting = false;
    let htmlAudioEl = null;
    let htmlAudioSrcNode = null;
    // Mic chain references
    let micStream = null;
    let micSourceNode = null;
    let micGainNode = null;
    let micConnected = false;
    let internalConnected = false;
    let cycleInterval = null;
    let presets = {};
    let presetKeys = [];
    let presetIndexHist = [];
    let presetIndex = 0;
    let presetCycle = true;
    let presetCycleLength = 15000;
    let presetRandom = true;
    let disabledSet = new Set();
    let hideDisabled = (localStorage.getItem('hideDisabled') || '0') === '1';
    let presetSearchTerm = '';

    let canvas; // assigned on DOMContentLoaded
    let hero;
    let settingsPanel;
    let playlistPanel;
    let busy;
    let toast;
    let live;
    let level;
    let gpuBadge;
    let analyser = null;
    let levelArray = null;
    let userSyncOffsetMs = Number(localStorage.getItem('syncOffsetMs') || '0');
    let modelsIndex = null;
    let pendingTapConnect = false;
    let includeClassicLocal = (localStorage.getItem('classicLocal') || '1') === '1';
    let embedMode = false;
    // Dancers runtime state
    const Dancers = (function(){
      const layerId = 'dancersLayer';
      let layerEl = null;
      let enabled = false;
      let list = [];
      let listWebp = [];
      let spawnTimer = 0;
      let lastT = 0;
      const maxOnScreen = 2;
      const minLifeSec = 5;
      const minDistPx = 120; // don't allow centers closer than this
      const basePath = '../assets/dancing_GIF/';
      const baseWebp = '../assets/dancing_WEBP/';
      async function init(){
        if (!layerEl) layerEl = document.getElementById(layerId);
        if (!layerEl) return;
        // Try to load index.json fallback to simple directory probe list
        try {
          const res = await fetch(basePath + 'index.json', { cache: 'no-cache' });
          if (res.ok) {
            const j = await res.json();
            let arr = Array.isArray(j) ? j : (Array.isArray(j.files) ? j.files : []);
            // Normalize entries (strings only)
            list = arr.map((x) => typeof x === 'string' ? x : (x?.file || x?.name || '')).filter(Boolean);
          }
        } catch(_) {}
        try {
          const res2 = await fetch(baseWebp + 'index.json', { cache: 'no-cache' });
          if (res2.ok) {
            const j2 = await res2.json();
            let arr2 = Array.isArray(j2) ? j2 : (Array.isArray(j2.files) ? j2.files : []);
            listWebp = arr2.map((x) => typeof x === 'string' ? x : (x?.file || x?.name || '')).filter(Boolean);
          }
        } catch(_) {}
        // Fallback lazy probe if index missing or empty: try to request a handful of known filenames
        if (!list || list.length === 0) {
          const probes = [
            'bubu-rub-bubu-love-dudu.gif','bubu-dudu-dudu-dance.gif','bubu-cute-dancing.gif','aqua-dancing-maxgames331535.gif'
          ];
          const ok = [];
          await Promise.all(probes.map(async (f)=>{
            try { const head = await fetch(basePath + f, { method: 'HEAD', cache: 'no-cache' }); if (head.ok) ok.push(f); } catch(_) {}
          }));
          list = ok;
        }
      }
      function pick(){
        const pools = [];
        if (list && list.length) pools.push({ base: basePath, arr: list });
        if (listWebp && listWebp.length) pools.push({ base: baseWebp, arr: listWebp });
        if (!pools.length) return null;
        const p = pools[Math.floor(Math.random()*pools.length)];
        const i = Math.floor(Math.random()*p.arr.length);
        return { base: p.base, file: p.arr[i] };
      }
      function getQuadrants(){
        const b = layerEl.getBoundingClientRect();
        const hw = Math.floor(b.width / 2);
        const hh = Math.floor(b.height / 2);
        return [
          { x: 0, y: 0, w: hw, h: hh, cx: hw/2, cy: hh/2 },               // TL (0)
          { x: hw, y: 0, w: b.width-hw, h: hh, cx: hw + (b.width-hw)/2, cy: hh/2 }, // TR (1)
          { x: 0, y: hh, w: hw, h: b.height-hh, cx: hw/2, cy: hh + (b.height-hh)/2 }, // BL (2)
          { x: hw, y: hh, w: b.width-hw, h: b.height-hh, cx: hw + (b.width-hw)/2, cy: hh + (b.height-hh)/2 }, // BR (3)
        ];
      }
      function createDancer(quadIndex, beatState){
        if (!layerEl) return null;
        const sel = pick(); if (!sel) return null; const url = sel.file.startsWith('http') ? sel.file : (sel.base + sel.file);
        const qs = getQuadrants(); const q = qs[Math.max(0, Math.min(3, quadIndex|0))];
        const existing = Array.from(layerEl.querySelectorAll('.dancer'));
        for (let attempt=0; attempt<4; attempt++){
          const el = document.createElement('img'); el.className = 'dancer'; el.alt = 'dancer'; el.decoding = 'async'; el.loading = 'lazy'; el.src = url;
          const z = Math.random();
          // Size strictly relative to quadrant: reduced scale for less clutter
          const maxFitW = q.w * 0.68; // tighter fit within quadrant
          const minFitW = Math.max(120, q.w * 0.38);
          const baseW = minFitW + (maxFitW - minFitW) * (0.4 + 0.6*z); // deeper smaller, foreground larger
          const w = Math.round(Math.max(120, Math.min(320, baseW)));
          const jitterX = (q.w * 0.10) * (Math.random()*2-1);
          const jitterY = (q.h * 0.08) * (Math.random()*2-1);
          const cx = q.cx + jitterX; const cy = q.cy + jitterY;
          const x = Math.round(Math.max(q.x+10, Math.min(q.x + q.w - w - 10, cx - w/2)));
          const y = Math.round(Math.max(q.y+10, Math.min(q.y + q.h - (w*1.1) - 10, cy - (w*1.1)/2)));
          // one per quadrant rule
          if (existing.some((e)=> (e.dataset.quad === String(quadIndex)))) { return null; }
          // proximity rule
          let ok = true;
          for (const other of existing){
            const ox = parseFloat(other.style.left||'0');
            const oy = parseFloat(other.style.top||'0');
            const ow = parseFloat(other.style.width||'120');
            const ocx = ox + ow/2; const ocy = oy + (ow*1.2)/2;
            const dist = Math.hypot((x+w/2)-ocx, (y+(w*1.1)/2)-ocy);
            if (dist < minDistPx) { ok = false; break; }
            if (other.getAttribute('src') === url && dist < (minDistPx*1.5)) { ok = false; break; }
          }
          if (!ok) continue;
          el.style.left = x + 'px'; el.style.top = y + 'px'; el.style.width = w + 'px';
          const mirrored = Math.random()<0.5; el.style.setProperty('--mx', mirrored ? '-1' : '1');
          el.style.setProperty('--sx', String(0.85 + Math.random()*0.25)); el.style.setProperty('--rot', (Math.random()*10-5) + 'deg');
          // Portal rotation: start edge-on, then rotate to face-forward
          el.style.setProperty('--ry', (Math.random()<0.5 ? '90deg' : '-90deg'));
          el.style.opacity = '0';
          const zIndex = 5 + Math.floor(z * 4);
          el.style.zIndex = String(zIndex);
          // Fade-in target and portal setup
          const targetOpacity = 0.85 + 0.15 * z;
          el.dataset.targetOpacity = String(targetOpacity);
          el.style.opacity = '0';
          if (z < 0.35) { el.style.mixBlendMode = 'multiply'; el.style.filter = 'blur(0.6px) saturate(1.0) drop-shadow(0 8px 24px rgba(0,0,0,0.35))'; }
          else if (z < 0.65) { el.style.mixBlendMode = 'overlay'; el.style.filter = 'saturate(1.1) drop-shadow(0 8px 24px rgba(0,0,0,0.35))'; }
          else { el.style.mixBlendMode = 'screen'; el.style.filter = 'saturate(1.2) drop-shadow(0 8px 24px rgba(0,0,0,0.35))'; }
          el.dataset.createdAt = String(performance.now()/1000);
          el.dataset.lifeSec = String(5 + Math.random()*5);
          el.dataset.quad = String(quadIndex);
          // Portal entry: start edge-on and disable keyframes to let CSS transition control rotateY
          const rySign = (Math.random()<0.5 ? -1 : 1);
          el.dataset.rySign = String(rySign);
          el.style.setProperty('--ry', (rySign > 0 ? '90deg' : '-90deg'));
          el.classList.add('no-tx');
          layerEl.appendChild(el);
          const emerge = () => {
            el.classList.add('in');
            requestAnimationFrame(()=>{
              el.style.setProperty('--ry', '0deg');
              // drive opacity via inline style so it transitions regardless of class specificity
              const to = parseFloat(el.dataset.targetOpacity || '1');
              el.style.opacity = String(to);
              const onEnd = (ev) => { if (ev.propertyName === 'transform') { el.classList.remove('no-tx'); el.removeEventListener('transitionend', onEnd); } };
              el.addEventListener('transitionend', onEnd);
              setTimeout(()=>{ el.classList.remove('no-tx'); }, 900); // safety
            });
          };
          if (beatState && (beatState.onDownbeat || beatState.onKick)) requestAnimationFrame(emerge);
          else setTimeout(emerge, 120 + Math.random()*420);
          return el;
        }
        return null;
      }
      function removeDancer(el){ if (!el) return; el.classList.remove('in');
        // Exit via portal: rotate back to edge-on and fade out, with controlled transition
        const rySign = parseInt(el.dataset.rySign || (Math.random()<0.5 ? '-1' : '1'), 10);
        el.classList.add('no-tx');
        el.classList.add('out');
        requestAnimationFrame(()=>{
          el.style.setProperty('--ry', (rySign > 0 ? '90deg' : '-90deg'));
          el.style.opacity = '0';
          const cleanup = () => { try { el.remove(); } catch(_){} };
          const onEnd = (ev) => { if (ev.propertyName === 'transform') { el.removeEventListener('transitionend', onEnd); cleanup(); } };
          el.addEventListener('transitionend', onEnd);
          setTimeout(cleanup, 900);
        });
      }
      function enable(on){ enabled = !!on; if (!layerEl) layerEl = document.getElementById(layerId); if (!enabled && layerEl) { Array.from(layerEl.querySelectorAll('.dancer')).forEach(removeDancer); } }
      function tick(dt, beatState){ if (!enabled || !layerEl) return; spawnTimer -= dt; // spawn on downbeat or timer
        const onDown = beatState && beatState.onDownbeat; const conf = beatState ? (beatState.confidence||0) : 0;
        let have = layerEl.querySelectorAll('.dancer').length;
        // desired count per spawn: 1..3
        const groupSize = 1 + Math.floor(Math.random()*2); // 1..2 only
        // ensure at least one dancer when enabled
        const target = Math.max(1, Math.min(maxOnScreen, groupSize));
        if (((onDown && Math.random()<0.7) || spawnTimer<=0 || have === 0) && have < maxOnScreen) {
          const quads = ['0','1','2','3'];
          const occ = new Set(Array.from(layerEl.querySelectorAll('.dancer')).map(d=>d.dataset.quad).filter(Boolean));
          const free = quads.filter(q => !occ.has(q));
          // ensure at least one empty quadrant: cap spawns to free.length-1 if needed
          const maxSpawn = Math.max(0, Math.min(target - have, Math.max(0, Math.min(2, free.length - 1))));
          // if nothing free but have < target, retire oldest beyond minLife to free one
          if (maxSpawn === 0 && have === 0) {
            // no dancers: allow placing into any quad
            free.push('0','1','2','3');
          }
          let count = 0;
          const toSpawn = Math.max(0, Math.min(maxSpawn, Math.max(0, maxOnScreen - have)));
          while (count < toSpawn && free.length) {
            const idx = Math.floor(Math.random()*free.length);
            const q = parseInt(free.splice(idx,1)[0], 10);
            const made = createDancer(q, beatState);
            if (made) { have++; count++; }
          }
          spawnTimer = 3.0; // 3s delay between spawns
        }
        // random retire and cinematic jitter
        Array.from(layerEl.querySelectorAll('.dancer')).forEach((el)=>{
          // minimum lifetime guard
          const createdAt = parseFloat(el.dataset.createdAt||'0');
          const lifeSec = parseFloat(el.dataset.lifeSec||'8');
          const alive = (performance.now()/1000) - createdAt;
          if (alive > lifeSec) removeDancer(el);
          else if (layerEl.querySelectorAll('.dancer').length > target && alive > 5 && Math.random()<0.05) removeDancer(el);
          else {
            // light beat jitter, cinematic punch on strong kicks
            if (beatState && beatState.onBeat) {
              const r = (Math.random()*2-1)*4; const s = 0.94 + Math.random()*0.12; el.style.setProperty('--rot', r+'deg'); el.style.setProperty('--sx', String(s));
              // subtle hue pop on hats
              if (beatState.onHat) el.style.filter = 'hue-rotate(' + Math.floor(Math.random()*60-30) + 'deg) saturate(1.25) drop-shadow(0 8px 24px rgba(0,0,0,0.35))';
              else el.style.filter = 'drop-shadow(0 8px 24px rgba(0,0,0,0.35)) saturate(1.05)';
            }
            if (beatState && beatState.onKick) {
              // brief scale pulse (reduced)
              el.style.setProperty('--sx', String(1.08 + Math.random()*0.14));
            }
          }
        });
      }
      return { init, enable, tick };
    })();
    window.Dancers = Dancers;

    function openModal(id) {
      const el = document.getElementById(id);
      if (el) { el.classList.add('open'); el.setAttribute('aria-hidden', 'false'); }
    }
    function closeModal(id) {
      const el = document.getElementById(id);
      if (el) { el.classList.remove('open'); el.setAttribute('aria-hidden', 'true'); }
    }

    function renderModelsPanel() {
      const catSel = document.getElementById('modelsCategory');
      const list = document.getElementById('modelsList');
      if (!catSel || !list) return;
      catSel.innerHTML = '';
      const cats = Object.keys(modelsIndex || {});
      cats.forEach((c) => {
        const opt = document.createElement('option');
        opt.value = c; opt.textContent = c; catSel.appendChild(opt);
      });
      const drawList = () => {
        list.innerHTML = '';
        const cat = catSel.value || cats[0];
        const items = (modelsIndex && modelsIndex[cat]) || [];
        items.forEach((it) => {
          const div = document.createElement('div');
          div.className = 'model-item';
          div.textContent = `${it.name}`;
          div.title = it.file;
          div.addEventListener('click', async () => {
            const sample = Math.max(1, parseInt(document.getElementById('modelsSample').value || '3', 10));
            const blend = Math.max(0, parseFloat(document.getElementById('modelsBlend').value || '1.5'));
            const preload = document.getElementById('modelsPreload').checked;
            const url = it.file.startsWith('http') ? it.file : ('../' + it.file.replace(/^\.?\/?/, ''));
            try {
              if (visualizer.loadModelWithTransition) {
                await visualizer.loadModelWithTransition(url, { sampleEvery: sample, blendTime: blend });
              } else if (visualizer.loadParticleModelFromURL) {
                await visualizer.loadParticleModelFromURL(url, { sampleEvery: sample, enabled: true });
              } else {
                throw new Error('Model loading not supported in this build');
              }
              visualizer.setModelEffectsEnabled(true);
              if (preload) localStorage.setItem('modelURL', url);
              showToast(`Loaded model: ${it.name}`);
            } catch (e) {
              console.error('Failed to load model', e);
              showToast(`Model load failed: ${e?.message || 'error'}`, true);
            }
          });
          list.appendChild(div);
        });
      };
      catSel.addEventListener('change', drawList);
      catSel.value = cats[0] || '';
      drawList();
    }
    function hideHero() {
      hero.classList.add('hidden');
    }

    function ensureAudioContext() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      return audioContext;
    }

    async function resolveSampleURL() {
      const candidates = [
        '../assets/audio/aatma-rama.mp3',
        '../audio/aatma-rama.mp3',
        '../src/audio/aatma-rama.mp3',
      ];
      for (const url of candidates) {
        try {
          const res = await fetch(url, { method: 'HEAD', cache: 'no-cache' });
          if (res && (res.ok || res.status === 0)) return url;
        } catch(_) {}
      }
      return 'https://cdn.jsdelivr.net/gh/veed-sync/sample-audio/atma-rama.mp3';
    }

    async function playSampleTrack() {
      ensureAudioContext();
      await audioContext.resume().catch(()=>{});
      // Stop Tab capture to avoid duplicates
      try { if (tabStream) { tabStream.getTracks().forEach(t=>t.stop()); tabStream = null; } } catch(_) {}
      // Pause any previous element
      try { if (htmlAudioEl) { try { htmlAudioEl.pause(); } catch(_) {} } } catch(_) {}
      htmlAudioEl = new Audio();
      htmlAudioEl.crossOrigin = 'anonymous';
      htmlAudioEl.muted = false; htmlAudioEl.volume = 1.0; htmlAudioEl.playsInline = true;
      htmlAudioEl.src = await resolveSampleURL();
      htmlAudioEl.loop = true;
      // Ensure element is in DOM for iOS policies
      try { if (!htmlAudioEl.parentNode) { htmlAudioEl.style.position='fixed'; htmlAudioEl.style.left='-9999px'; htmlAudioEl.style.width='1px'; htmlAudioEl.style.height='1px'; document.body.appendChild(htmlAudioEl); } } catch(_) {}
      // (Re)create source node
      try { if (htmlAudioSrcNode) { try { htmlAudioSrcNode.disconnect(); } catch(_) {} htmlAudioSrcNode = null; } } catch(_) {}
      htmlAudioSrcNode = audioContext.createMediaElementSource(htmlAudioEl);
      connectToAudioTap(htmlAudioSrcNode);
      // Route to speakers
      try { await htmlAudioEl.play(); } catch(e) { console.error('Autoplay failed', e); }
      // Apply internal mode visuals & monitoring
      internalMethod = 'element'; try { localStorage.setItem('internalMethod','element'); } catch(_) {}
      syncAudioControls('internal', 'element');
      try { localStorage.setItem('monitorAudio','1'); } catch(_) {}
      try { if (tapNode && audioContext?.destination) { try { tapNode.disconnect(audioContext.destination); } catch(_) {} tapNode.connect(audioContext.destination); } } catch(_) {}
      if (visualizer?.renderer?.setMicActive) { visualizer.renderer.setMicActive(false, 1.5); }
      showToast('Playing sample: Atma Rama');
    }

    function connectToAudioTap(node) {
      ensureAudioContext();
      if (!tapNode) {
        tapNode = audioContext.createGain();
        tapNode.gain.value = 1.0;
        // Create analyser once and keep connected
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048;
        levelArray = new Uint8Array(analyser.frequencyBinCount);
        tapNode.connect(analyser);
        // Route to destination based on monitor toggle (never monitor Tab Capture)
        const monitorRequested = (localStorage.getItem('monitorAudio') || '1') === '1';
        const monitor = monitorRequested && !(internalMethod === 'tab');
        try { tapNode.disconnect(); } catch(_) {}
        tapNode.connect(analyser);
        if (monitor) tapNode.connect(audioContext.destination);
        setupLevelMeter();
      }
      node.connect(tapNode);
      if (visualizer && visualizer.connectAudio) {
        visualizer.connectAudio(tapNode);
        pendingTapConnect = false;
      } else {
        pendingTapConnect = true;
      }
    }

    function startRenderer() {
      if (rendering) return;
      if (!visualizer || !ensureAudioContext()) { showToast('Initializing…'); return; }
      rendering = true;
      let lastAudioT = null;
      const loop = () => {
        if (!rendering) return;
        // Drive elapsed from audio clock for tighter sync
        // Ensure context is running
        if (audioContext && audioContext.state === 'suspended') {
          audioContext.resume().catch(() => {});
        }
        const t = getAudioNow();
        let dt = 0;
        if (lastAudioT != null) dt = Math.max(1/240, Math.min(0.2, t - lastAudioT));
        lastAudioT = t;
        const res = visualizer.render({ elapsedTime: dt });
        try { Dancers.tick(dt, visualizer?.renderer?.beatState || null); } catch(_) {}
        // After render, adapt glass opacity based on current frame luminance
        updateGlassOpacity();
        rafId = requestAnimationFrame(loop);
      };
      rafId = requestAnimationFrame(loop);
      hideHero();
      setPlayState(true);
    }

    function stopRenderer() {
      rendering = false;
      if (rafId) cancelAnimationFrame(rafId);
      setPlayState(false);
    }

    function setPlayState(isPlaying) {
      const btn = document.getElementById('playBtn');
      if (!btn) return;
      btn.innerHTML = isPlaying ? '<i class="fa-solid fa-pause"></i>' : '<i class="fa-solid fa-play"></i>';
      btn.setAttribute('aria-pressed', isPlaying ? 'true' : 'false');
      btn.title = isPlaying ? 'Pause' : 'Render';
    }

    function playBufferSource(buffer) {
      startRenderer();
      if (sourceNode) {
        sourceNode.disconnect();
      }
      ensureAudioContext();
      if (internalMethod === 'element') {
        try { htmlAudioEl?.pause?.(); } catch(_) {}
        htmlAudioEl = new Audio();
        const blob = new Blob([buffer.getChannelData ? buffer.getChannelData(0).buffer : buffer], { type: 'audio/wav' });
        // Fallback: when we already have decoded buffer, rebuild via OfflineAudioContext for URL is complex.
        // So default to bufferSource path when we only have decoded PCM.
        // Element path will be used when loading file directly (see playFileViaElement).
        sourceNode = audioContext.createBufferSource();
        sourceNode.buffer = buffer;
        connectToAudioTap(sourceNode);
        sourceNode.start(0);
      } else {
        sourceNode = audioContext.createBufferSource();
        sourceNode.buffer = buffer;
        connectToAudioTap(sourceNode);
        sourceNode.start(0);
      }
      announce('Playing local audio');
    }

    function loadLocalFiles(fileList, index = 0) {
      ensureAudioContext();
      audioContext.resume();
      showBusy(true, 'Decoding audio…');
      const reader = new FileReader();
      reader.onload = (event) => {
        if (internalMethod === 'element') {
          try { htmlAudioEl?.pause?.(); } catch(_) {}
          htmlAudioEl = new Audio();
          const blob = new Blob([event.target.result]);
          const url = URL.createObjectURL(blob);
          htmlAudioEl.src = url;
          htmlAudioEl.crossOrigin = 'anonymous';
          htmlAudioEl.autoplay = true;
          htmlAudioEl.onplay = () => {
            try {
              const mediaSrc = audioContext.createMediaElementSource(htmlAudioEl);
              connectToAudioTap(mediaSrc);
              showBusy(false);
              showToast('Now playing (element capture)');
            } catch (e) {
              console.warn('Element capture failed, falling back', e);
            }
          };
          htmlAudioEl.play().catch(() => {});
        } else {
          audioContext.decodeAudioData(
            event.target.result,
            (buf) => {
              playBufferSource(buf);
              setTimeout(() => {
                if (fileList.length > index + 1) {
                  loadLocalFiles(fileList, index + 1);
                } else {
                  if (sourceNode) {
                    sourceNode.disconnect();
                    sourceNode = null;
                  }
                }
              }, buf.duration * 1000);
              showBusy(false);
              showToast('Now playing: local file');
            }
          );
        }
      };
      reader.readAsArrayBuffer(fileList[index]);
    }

    async function connectMic() {
      const useRNNoise = (localStorage.getItem('rnnoise') || '0') === '1';
      const sensitivity = Number(localStorage.getItem('micSensitivity') || '1.4');
      const constraints = { audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: false } };
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        console.error('getUserMedia not supported');
        return;
      }
      try {
        ensureAudioContext();
        audioContext.resume();
        const res = useRNNoise && visualizer.startMicCaptureEnhanced
          ? await visualizer.startMicCaptureEnhanced({ constraints, suppression: 'rnnoise', sensitivity })
          : await visualizer.startMicCapture(constraints);
        micStream = res.stream;
        micSourceNode = audioContext.createMediaStreamSource(micStream);
        micGainNode = audioContext.createGain();
        micGainNode.gain.value = sensitivity;
        micSourceNode.connect(micGainNode);
        connectToAudioTap(micGainNode);
        micConnected = true;
        startRenderer();
        showToast(`Mic connected${useRNNoise ? ' (RNNoise)' : ''}`);
        announce('Microphone connected');
        try { document.getElementById('micBtn').classList.add('mic-on'); } catch(_) {}
      } catch (err) {
        console.error('Error getting audio stream from getUserMedia', err);
        showToast('Mic permission denied', true);
        announce('Microphone permission denied');
        try { document.getElementById('micBtn').classList.remove('mic-on'); } catch(_) {}
      }
    }

    function disconnectMic(stopStream = true) {
      try { micSourceNode && micSourceNode.disconnect(); } catch(_) {}
      try { micGainNode && micGainNode.disconnect(); } catch(_) {}
      if (stopStream && micStream) {
        try { micStream.getTracks().forEach(t => t.stop()); } catch(_) {}
      }
      micSourceNode = null;
      micGainNode = null;
      if (stopStream) micStream = null;
      micConnected = false;
      try { document.getElementById('micBtn').classList.remove('mic-on'); } catch(_) {}
      showToast('Mic off');
      announce('Microphone disconnected');
    }

    function nextPreset(blendTime = 5.7) {
      if (!visualizer) { showToast('Initializing…'); return; }
      presetIndexHist.push(presetIndex);
      const pool = getEnabledKeys();
      if (!pool.length) { showToast('No presets enabled', true); return; }
      if (presetRandom) {
        presetIndex = presetKeys.indexOf(pool[Math.floor(Math.random() * pool.length)]);
      } else {
        let i = presetIndex;
        for (let step = 0; step < presetKeys.length; step++) {
          i = (i + 1) % presetKeys.length;
          if (!isDisabled(presetKeys[i])) { presetIndex = i; break; }
        }
      }
      const key = presetKeys[presetIndex];
      visualizer.loadPreset(presets[key], blendTime);
      try { visualizer.renderer?.applyStyleFromName?.(key); } catch(_) {}
      highlightActivePreset();
      showPresetToast(key);
    }

    function prevPreset(blendTime = 5.7) {
      if (!visualizer) { showToast('Initializing…'); return; }
      const numPresets = presetKeys.length;
      if (presetIndexHist.length > 0) {
        presetIndex = presetIndexHist.pop();
      } else {
        let i = presetIndex;
        for (let step = 0; step < numPresets; step++) {
          i = ((i - 1) + numPresets) % numPresets;
          if (!isDisabled(presetKeys[i])) { presetIndex = i; break; }
        }
      }
      const key = presetKeys[presetIndex];
      visualizer.loadPreset(presets[key], blendTime);
      try { visualizer.renderer?.applyStyleFromName?.(key); } catch(_) {}
      highlightActivePreset();
      showPresetToast(key);
    }

    function restartCycleInterval() {
      if (cycleInterval) {
        clearInterval(cycleInterval);
        cycleInterval = null;
      }
      if (presetCycle) {
        cycleInterval = setInterval(() => nextPreset(2.7), presetCycleLength);
      }
    }

    // Audio mode handling
    function applyAudioMode(mode) {
      // mode: 'mic' | 'internal' | 'both'
      localStorage.setItem('audioMode', mode);
      // Ensure mic initialized if needed
      if ((mode === 'mic' || mode === 'both') && !micSourceNode) {
        connectMic();
      }
      // Mic routing
      if (micGainNode) {
        try { micSourceNode.disconnect(); micSourceNode.connect(micGainNode); } catch(_) {}
        try { micGainNode.disconnect(); } catch(_) {}
        if (mode === 'mic' || mode === 'both') {
          micGainNode.gain.value = (mode === 'mic') ? 1.6 : 1.35; // amplify responsiveness to mic
          micGainNode.connect(tapNode);
          micConnected = true;
        } else {
          // Fully detach mic from graph
          try { micSourceNode.disconnect(); } catch(_) {}
          try { micGainNode.disconnect(); } catch(_) {}
          micConnected = false;
        }
      }
      // Update mic indicator
      try { (micConnected ? document.getElementById('micBtn').classList.add('mic-on') : document.getElementById('micBtn').classList.remove('mic-on')); } catch(_) {}
      // Internal routing (local file buffer source)
      if (sourceNode) {
        try { sourceNode.disconnect(); } catch(_) {}
        if (mode === 'internal' || mode === 'both') {
          sourceNode.connect(tapNode);
          internalConnected = true;
        } else {
          internalConnected = false;
        }
      }
      // Element audio (if used)
      if (htmlAudioEl && (mode === 'internal' || mode === 'both')) {
        try {
          try { htmlAudioSrcNode && htmlAudioSrcNode.disconnect(); } catch(_) {}
          htmlAudioSrcNode = audioContext.createMediaElementSource(htmlAudioEl);
          htmlAudioSrcNode.connect(tapNode);
        } catch(_) {}
      }
      // Tab capture handling
      if (internalMethod === 'tab' && (mode === 'internal' || mode === 'both')) {
        if (!tabCaptureStarting && !tabStream) startTabAudioCapture();
        // Ensure no monitoring to avoid duplicated sound
        try {
          localStorage.setItem('monitorAudio', '0');
          if (tapNode && audioContext?.destination) {
            try { tapNode.disconnect(audioContext.destination); } catch(_) {}
          }
        } catch(_) {}
      }
      showToast(`Audio mode: ${mode}`);
    }

    async function startTabAudioCapture() {
      if (tabCaptureStarting) return;
      try {
        tabCaptureStarting = true;
        ensureAudioContext();
        await audioContext.resume();
        // Ensure no local element keeps playing when switching to Tab capture
        try {
          if (htmlAudioEl) { try { htmlAudioEl.pause(); } catch(_) {} }
          if (htmlAudioSrcNode) { try { htmlAudioSrcNode.disconnect(); } catch(_) {} htmlAudioSrcNode = null; }
        } catch(_) {}
        if (tabStream) { try { tabStream.getTracks().forEach(t => t.stop()); } catch(_) {} tabStream = null; }
        const stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: { echoCancellation: false } });
        tabStream = stream;
        const tabSource = audioContext.createMediaStreamSource(stream);
        connectToAudioTap(tabSource);
        internalConnected = true;
        showToast('Tab audio capture started');
      } catch (e) {
        console.error('Tab capture failed', e);
        showToast('Tab capture failed', true);
      } finally {
        tabCaptureStarting = false;
      }
    }

    function resizeRenderer() {
      const top = document.getElementById('topbar').offsetHeight;
      const bottom = document.getElementById('bottombar').offsetHeight;
      const width = window.innerWidth;
      const height = window.innerHeight - top - bottom;
      canvas.width = width;
      canvas.height = height;
      if (visualizer) {
        visualizer.setRendererSize(width, height);
      }
    }

    function currentBackendPref() {
      const sel = document.getElementById('settingBackend');
      return sel ? sel.value : (localStorage.getItem('backendPref') || 'auto');
    }

    function currentDirectPref() {
      const el = document.getElementById('settingDirect');
      if (el) return !!el.checked;
      const stored = localStorage.getItem('directDraw');
      return stored ? stored === '1' : false;
    }

    function reinitVisualizer() {
      const backendPref = currentBackendPref();
      const direct = currentDirectPref();
      localStorage.setItem('backendPref', backendPref);
      localStorage.setItem('directDraw', direct ? '1' : '0');

      const width = canvas.width;
      const height = canvas.height;

      const backend = backendPref === 'webgpu-exp' ? 'webgpu' : backendPref;

      // WebGPU effects prefs
      const wgpuModeSel = document.getElementById('settingWgpuMode');
      const wgpuEffectSel = document.getElementById('settingWgpuEffect');
      const wgpuP1El = document.getElementById('settingWgpuP1');
      const wgpuMode = wgpuModeSel ? wgpuModeSel.value : (localStorage.getItem('wgpuMode') || 'off');
      const wgpuEffect = wgpuEffectSel ? wgpuEffectSel.value : (localStorage.getItem('wgpuEffect') || 'pulsebloom');
      const wgpuP1 = wgpuP1El ? parseFloat(wgpuP1El.value || '0.5') : parseFloat(localStorage.getItem('wgpuP1') || '0.5');

      // Stop current renderer loop
      const wasRendering = rendering;
      stopRenderer();

      try { visualizer?.loseGLContext?.(); } catch(_) {}
      visualizer = veedSync.createVisualizer(audioContext, canvas, {
        width,
        height,
        pixelRatio: window.devicePixelRatio || 1,
        textureRatio: 1,
        backend,
        directCanvas: direct,
        webgpuEffectMode: wgpuMode,
        webgpuEffectName: wgpuEffect,
        webgpuEffectParams: { param1: wgpuP1 }
      });

      // Reconnect audio tap if present
      if (tapNode) {
        try { visualizer.connectAudio(tapNode); } catch(_) {}
      }
      // Reload current preset
      try {
        if (presetKeys.length) visualizer.loadPreset(presets[presetKeys[presetIndex]], 0);
      } catch (e) {
        console.error('Failed to load preset after reinit', e);
        showToast('Failed to apply backend change', true);
      }

      if (wasRendering) startRenderer();
      announce('Graphics backend updated');
    }

    function showBusy(state, label = 'Working…') {
      busy.setAttribute('aria-hidden', state ? 'false' : 'true');
      busy.style.opacity = state ? '1' : '0';
      busy.querySelector('.busy-label').textContent = label;
    }

    function showToast(message, isError = false) {
      toast.textContent = message;
      toast.classList.remove('error');
      if (isError) toast.classList.add('error');
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), 2200);
    }
    function showPresetToast(name) {
      toast.classList.remove('error');
      toast.innerHTML = '';
      const span = document.createElement('span');
      span.textContent = `Now showing: ${name}`;
      const btn = document.createElement('button');
      btn.textContent = 'Disable';
      btn.style.marginLeft = '10px';
      btn.className = 'btn small';
      btn.addEventListener('click', () => { disableCurrentPreset(); });
      toast.appendChild(span);
      toast.appendChild(btn);
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), 2500);
    }
    function saveDisabled() { try { localStorage.setItem('disabledPresets', JSON.stringify(Array.from(disabledSet))); } catch(_) {} }
    function loadDisabled() {
      try { const arr = JSON.parse(localStorage.getItem('disabledPresets') || '[]'); if (Array.isArray(arr)) disabledSet = new Set(arr); } catch(_) { disabledSet = new Set(); }
    }
    function isDisabled(key) { return disabledSet.has(key); }
    function getEnabledKeys() { return presetKeys.filter((k) => !isDisabled(k)); }
    function disablePresetByKey(key) { disabledSet.add(key); saveDisabled(); buildPlaylist(); }
    function enablePresetByKey(key) { disabledSet.delete(key); saveDisabled(); buildPlaylist(); }
    function disableCurrentPreset() { const key = presetKeys[presetIndex]; if (!key) return; disablePresetByKey(key); showToast('Preset disabled'); nextPreset(0.5); }

    function announce(message) {
      live.textContent = '';
      setTimeout(() => live.textContent = message, 10);
    }

    function setupLevelMeter() {
      const draw = () => {
        if (analyser && levelArray) {
          analyser.getByteFrequencyData(levelArray);
          const avg = levelArray.reduce((a, b) => a + b, 0) / levelArray.length;
          const pct = Math.min(100, Math.max(0, (avg / 255) * 100));
          level.style.width = pct + '%';
        }
        requestAnimationFrame(draw);
      };
      requestAnimationFrame(draw);
    }

    function getAudioNow() {
      if (!audioContext) {
        return (performance.now() / 1000) + userSyncOffsetMs / 1000;
      }
      try {
        if (audioContext && typeof audioContext.getOutputTimestamp === 'function') {
          const ts = audioContext.getOutputTimestamp();
          return (ts && ts.contextTime ? ts.contextTime : audioContext.currentTime) + userSyncOffsetMs / 1000;
        }
      } catch (_) {}
      const base = (audioContext.baseLatency || 0) + (audioContext.outputLatency || 0);
      return audioContext.currentTime + base + userSyncOffsetMs / 1000;
    }

    // Dynamic background luminance sampling to adapt glass opacity
    let luminanceProbe = null;
    function initLuminanceProbe() {
      try {
        luminanceProbe = document.createElement('canvas');
        luminanceProbe.width = 64; luminanceProbe.height = 64;
        luminanceProbe.style.display = 'none';
        document.body.appendChild(luminanceProbe);
      } catch(_) {}
    }
    function updateGlassOpacity() {
      if (!visualizer || !luminanceProbe) return;
      try {
        const ctx = luminanceProbe.getContext('2d', { willReadFrequently: false });
        if (!ctx) return;
        ctx.drawImage(canvas, 0, 0, luminanceProbe.width, luminanceProbe.height);
        const data = ctx.getImageData(0, 0, luminanceProbe.width, luminanceProbe.height).data;
        let sum = 0;
        for (let i = 0; i < data.length; i += 4) {
          const r = data[i] / 255, g = data[i+1] / 255, b = data[i+2] / 255;
          // Rec. 709 luma
          sum += 0.2126*r + 0.7152*g + 0.0722*b;
        }
        const avgY = sum / (data.length / 4);
        // Map luminance to extra darkening; threshold around 0.55
        const t = Math.max(0, avgY - 0.55);
        const darkBoost = Math.min(0.35, t * 0.85); // cap extra darkening
        document.documentElement.style.setProperty('--bar-darken', String(darkBoost));
        document.documentElement.style.setProperty('--panel-darken', String(darkBoost * 1.1));
      } catch(_) {}
    }
    function applyVibeKey(key){
      try {
        if (!visualizer || !visualizer.renderer) return;
        if (key === 'water') visualizer.renderer.applySceneWater?.();
        else if (key === 'beach') visualizer.renderer.applySceneBeach?.();
        else if (key === 'party') visualizer.renderer.applySceneParty?.();
        else if (key === 'chill') visualizer.renderer.setPostFX?.({ saturation: -0.08, tint: [0.94,1.02,1.06], tonemap: 0.6 });
        else if (key === 'storm') visualizer.renderer.setPostFX?.({ contrast: 0.16, grain: 0.12, tint: [0.96,0.98,1.04] });
      } catch(_) {}
    }

    function buildPlaylist() {
      const list = document.getElementById('presetList');
      list.innerHTML = '';
      const raw = hideDisabled ? presetKeys.filter((k) => !isDisabled(k)) : presetKeys;
      const q = (document.getElementById('presetSearch')?.value || presetSearchTerm || '').toLowerCase().trim();
      const keysForList = q ? raw.filter((k) => k.toLowerCase().includes(q)) : raw;

      // Update meta
      const metaNow = document.getElementById('presetNow');
      const metaCount = document.getElementById('presetCount');
      if (metaNow) metaNow.textContent = presetKeys[presetIndex] ? presetKeys[presetIndex].substring(0, 80) : '—';
      if (metaCount) metaCount.textContent = `${keysForList.length} of ${raw.length}`;
      keysForList.forEach((key) => {
        const i = presetKeys.indexOf(key);
        const li = document.createElement('li');
        const title = document.createElement('span');
        title.className = 'title';
        title.textContent = key;
        li.appendChild(title);
        li.dataset.index = i;
        if (isDisabled(key)) li.classList.add('disabled');
        const action = document.createElement('button');
        action.className = 'btn small';
        action.style.marginLeft = '10px';
        action.title = isDisabled(key) ? 'Enable preset' : 'Disable preset';
        action.innerHTML = isDisabled(key) ? '<i class="fa-solid fa-rotate"></i>' : '<i class="fa-solid fa-ban"></i>';
        action.addEventListener('click', (e) => {
          e.stopPropagation();
          if (isDisabled(key)) enablePresetByKey(key); else disablePresetByKey(key);
          showToast(isDisabled(key) ? 'Preset disabled' : 'Preset enabled');
        });
        li.addEventListener('click', () => {
          presetIndex = i;
          visualizer.loadPreset(presets[key], 0.5);
          highlightActivePreset();
          playlistPanel.classList.remove('open');
          showPresetToast(key);
        });
        li.appendChild(action);
        list.appendChild(li);
      });
      highlightActivePreset();
    }

    // Sidebar removed

    function highlightActivePreset() {
      const list = document.getElementById('presetList');
      const items = list.querySelectorAll('li');
      items.forEach((li) => li.classList.remove('active'));
      const active = list.querySelector(`li[data-index="${presetIndex}"]`);
      if (active) active.classList.add('active');
      const metaNow = document.getElementById('presetNow');
      if (metaNow) metaNow.textContent = presetKeys[presetIndex] ? presetKeys[presetIndex].substring(0, 80) : '—';
    }

    // Fallback loader in case CDN preset scripts didn't attach
    function loadScriptOnce(src) {
      return new Promise((resolve, reject) => {
        const existing = Array.from(document.querySelectorAll('script')).some(s => s.src === src);
        if (existing) { resolve(); return; }
        const s = document.createElement('script');
        s.src = src; s.async = true; s.crossOrigin = 'anonymous';
        s.onload = () => resolve();
        s.onerror = () => reject(new Error('Failed to load ' + src));
        document.head.appendChild(s);
      });
    }

    async function ensurePresetGlobals() {
      if (window.base && window.extra) return;
      try {
        await loadScriptOnce('https://cdn.jsdelivr.net/npm/butterchurn-presets@3.0.0-beta.4/dist/base.min.js');
        await loadScriptOnce('https://cdn.jsdelivr.net/npm/butterchurn-presets@3.0.0-beta.4/dist/extra.min.js');
      } catch (_) { /* ignore, we'll proceed with whatever is available */ }
    }

    async function initPlayer() {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();

      // WebGPU detection & badge (non-blocking)
      (async () => {
        try {
          if (navigator.gpu) {
            const adapter = await navigator.gpu.requestAdapter({ powerPreference: 'high-performance' });
            const device = adapter && await adapter.requestDevice();
            if (device) {
              gpuBadge.textContent = 'WebGPU';
              gpuBadge.classList.add('ok');
              const aw = document.getElementById('aboutWebgpu'); if (aw) aw.textContent = 'available';
              const ag = document.getElementById('aboutGpu'); if (ag) ag.textContent = 'WebGPU';
              return;
            }
          }
        } catch(_) {}
        gpuBadge.textContent = 'WebGL2';
        const ag = document.getElementById('aboutGpu'); if (ag) ag.textContent = 'WebGL2';
      })();
      presets = {};
      await ensurePresetGlobals();
      loadDisabled();
      if (window.base && window.base.default) Object.assign(presets, window.base.default);
      if (window.extra && window.extra.default) Object.assign(presets, window.extra.default);
      // Optionally add a few classic local presets shipped in repo
      const mergeClassic = async () => {
        if (!includeClassicLocal) return;
        const localList = [
          { name: 'Aderrasi - Mother Of Pearl (classic)', path: '../experiments/wasm-eel/presets/Aderrasi - Mother Of Pearl - mash0000 - how to piss off your eyes.json' },
          { name: 'Aderrasi - Potion of Spirits (classic)', path: '../experiments/wasm-eel/presets/Aderrasi - Potion of Spirits.json' },
          { name: 'Rovastar + Geiss - Hurricane Nightmare (classic)', path: '../experiments/wasm-eel/presets/_Rovastar + Geiss - Hurricane Nightmare (Posterize Mix).json' }
        ];
        for (const item of localList) {
          try {
            const res = await fetch(encodeURI(item.path));
            if (res.ok) {
              const obj = await res.json();
              presets[item.name] = obj;
            }
          } catch (_) {}
        }
      };
      await mergeClassic();
      // Optionally load new preset pack if toggled
      async function rebuildPresets(newOnly){
        presets = {};
        if (!newOnly) {
          if (window.base && window.base.default) Object.assign(presets, window.base.default);
          if (window.extra && window.extra.default) Object.assign(presets, window.extra.default);
        }
        try {
          const res = await fetch('../assets/new-presets/index.json', { cache: 'no-cache' });
          if (res.ok) {
            const list = await res.json();
            for (const item of list) {
              try { const r = await fetch(encodeURI(item.path)); if (r.ok) presets[item.name] = await r.json(); } catch(_) {}
            }
          }
        } catch(_) {}
        // sort and rebuild keys
        const entries = Object.entries(presets);
        entries.sort((a, b) => a[0].toLowerCase().localeCompare(b[0].toLowerCase()));
        presets = Object.fromEntries(entries);
        presetKeys = entries.map(([k]) => k);
        presetIndex = Math.min(presetIndex, Math.max(0, presetKeys.length - 1));
      }
      window.rebuildPresets = rebuildPresets;
      const newOnlyInit = (localStorage.getItem('newPresetsOnly') || '0') === '1';
      if (newOnlyInit) { await rebuildPresets(true); }
      // Sort presets case-insensitively without relying on lodash
      {
        const entries = Object.entries(presets);
        entries.sort((a, b) => a[0].toLowerCase().localeCompare(b[0].toLowerCase()));
        presets = Object.fromEntries(entries);
        presetKeys = entries.map(([k]) => k);
      }
      presetIndex = Math.floor(Math.random() * presetKeys.length);

      // Apply stored backend prefs
      const backendPref = localStorage.getItem('backendPref') || 'auto';
      const direct = (localStorage.getItem('directDraw') || '0') === '1';
      const backend = backendPref === 'webgpu-exp' ? 'webgpu' : backendPref;

      visualizer = veedSync.createVisualizer(audioContext, canvas, {
        width: 800,
        height: 600,
        pixelRatio: window.devicePixelRatio || 1,
        textureRatio: 1,
        backend,
        directCanvas: direct
      });
      // Compatibility shim: ensure model transition API exists by falling back to particle model loader
      if (!visualizer.loadModelWithTransition && visualizer.loadParticleModelFromURL) {
        visualizer.loadModelWithTransition = async (url, opts = {}) => {
          const sampleEvery = opts.sampleEvery || 4;
          await visualizer.loadParticleModelFromURL(url, { sampleEvery, enabled: true });
        };
      }
      if (pendingTapConnect && tapNode && visualizer?.connectAudio) {
        try { visualizer.connectAudio(tapNode); } catch(_) {}
        pendingTapConnect = false;
      }
      // Apply stored particle settings
      const particlesOn = (localStorage.getItem('particlesOn') || '0') === '1';
      const particlesCount = parseInt(localStorage.getItem('particlesCount') || '600', 10);
      visualizer.setParticlesEnabled?.(particlesOn);
      visualizer.configureParticles?.({ maxCount: particlesCount });
      // Apply stored model FX settings and preload a model if present
      const modelFx = (localStorage.getItem('modelFx') || '0') === '1';
      const modelOnly = (localStorage.getItem('modelOnly') || '0') === '1';
      visualizer.setModelEffectsEnabled?.(modelFx);
      visualizer.setModelOnlyMode?.(modelOnly);
      const preloadModel = localStorage.getItem('modelURL');
      if (preloadModel) {
        try {
          if (visualizer.loadModelWithTransition) {
            await visualizer.loadModelWithTransition(preloadModel, { blendTime: 1.5, sampleEvery: 3 });
          } else if (visualizer.loadParticleModelFromURL) {
            await visualizer.loadParticleModelFromURL(preloadModel, { sampleEvery: 3, enabled: true });
          }
        } catch(_) {}
      }
      try {
        visualizer.loadPreset(presets[presetKeys[presetIndex]], 0);
        showPresetToast(presetKeys[presetIndex]);
      } catch (e) {
        console.error('Failed to load preset', e);
        showToast('Failed to load preset', true);
      }
      restartCycleInterval();
      buildPlaylist();
      resizeRenderer();
      window.addEventListener('resize', resizeRenderer);
      // Auto-start rendering so the user sees visuals immediately
      try { startRenderer(); } catch (_) {}

      // Preset chips inside playlist panel
      const chipBase = document.getElementById('chipBase');
      const chipExtra = document.getElementById('chipExtra');
      const chipNewOnly = document.getElementById('chipNewOnly');
      const presetSearch = document.getElementById('presetSearch');
      function applyPresetChips(){
        const newOnly = !!chipNewOnly?.checked;
        localStorage.setItem('newPresetsOnly', newOnly ? '1' : '0');
        const state = { base: !!chipBase?.checked, extra: !!chipExtra?.checked };
        localStorage.setItem('packsBase', state.base ? '1' : '0');
        localStorage.setItem('packsExtra', state.extra ? '1' : '0');
        const doRebuild = async () => {
          presets = {};
          if (!newOnly) {
            if (state.base && window.base?.default) Object.assign(presets, window.base.default);
            if (state.extra && window.extra?.default) Object.assign(presets, window.extra.default);
          }
          try {
            const res = await fetch('../assets/new-presets/index.json', { cache: 'no-cache' });
            if (res.ok) {
              const list = await res.json();
              for (const item of list) { try { const r = await fetch(encodeURI(item.path)); if (r.ok) presets[item.name] = await r.json(); } catch(_) {} }
            }
          } catch(_) {}
          const entries = Object.entries(presets);
          entries.sort((a,b)=>a[0].toLowerCase().localeCompare(b[0].toLowerCase()));
          presets = Object.fromEntries(entries); presetKeys = entries.map(([k])=>k);
          presetIndex = Math.min(presetIndex, Math.max(0, presetKeys.length - 1));
          buildPlaylist();
          showToast('Presets updated');
        };
        doRebuild();
      }
      if (chipBase) chipBase.checked = (localStorage.getItem('packsBase') || '1') === '1';
      if (chipExtra) chipExtra.checked = (localStorage.getItem('packsExtra') || '1') === '1';
      if (chipNewOnly) chipNewOnly.checked = (localStorage.getItem('newPresetsOnly') || '0') === '1';
      chipBase?.addEventListener('change', applyPresetChips);
      chipExtra?.addEventListener('change', applyPresetChips);
      chipNewOnly?.addEventListener('change', applyPresetChips);
      presetSearch?.addEventListener('input', (e)=>{ presetSearchTerm = (e.target.value||'').toLowerCase(); buildPlaylist(); });
      // Try to load models index for the Models panel
      try {
        const res = await fetch('../assets/models/index.json', { cache: 'no-cache' });
        if (res.ok) modelsIndex = await res.json();
      } catch (_) {}
    }

    // UI wiring
    window.addEventListener('DOMContentLoaded', () => {
      try {
        const params = new URLSearchParams(window.location.search);
        embedMode = params.has('embed') || params.get('embed') === '1';
        if (embedMode) document.body.classList.add('embed');
      } catch(_) {}
      // Bind DOM refs now that elements exist
      canvas = document.getElementById('canvas');
      hero = document.getElementById('hero');
      settingsPanel = document.getElementById('settingsPanel');
      playlistPanel = document.getElementById('playlistPanel');
      busy = document.getElementById('busy');
      toast = document.getElementById('toast');
      live = document.getElementById('live');
      level = document.getElementById('level');
      gpuBadge = document.getElementById('gpuBadge');
      if (gpuBadge) gpuBadge.textContent = 'Detecting…';
      // Sidebar removed

      // Wire UI first; initialize player after to avoid blocking buttons if init errors
      // Init luminance probe for adaptive glass opacity
      initLuminanceProbe();
      // Init dancers
      Dancers.init();

      // Starter overlay logic
      const starter = document.getElementById('starter');
      const firstRunKey = 'starterSeenV1';
      const seen = localStorage.getItem(firstRunKey) === '1';
      if (!seen) { starter.classList.add('open'); }

      // Always wire starter handlers so Audio menu works anytime
      (function wireStarterHandlers(){
        const det = document.getElementById('starterDetect');
        const mic = document.getElementById('starterMic');
        const samp = document.getElementById('starterSample');
        if (det && !det.dataset.wired) {
          det.dataset.wired = '1';
          det.addEventListener('click', async () => {
            try { localStorage.setItem(firstRunKey, '1'); } catch(_) {}
            internalMethod = 'tab'; try { localStorage.setItem('internalMethod', 'tab'); } catch(_) {}
            hideStarter(); startRenderer();
            try { if (!tabCaptureStarting && !tabStream) await startTabAudioCapture(); } catch(_) {}
            applyAudioMode('internal');
            syncAudioControls('internal', 'tab');
            setMonitorEnabled(false);
          });
        }
        if (mic && !mic.dataset.wired) {
          mic.dataset.wired = '1';
          mic.addEventListener('click', async () => {
            try { localStorage.setItem(firstRunKey, '1'); } catch(_) {}
            applyAudioMode('mic');
            if (visualizer?.renderer?.setMicActive) { visualizer.renderer.setMicActive(true, 1.8); }
            syncAudioControls('mic', localStorage.getItem('internalMethod') || 'auto');
            hideStarter(); startRenderer();
          });
        }
        if (samp && !samp.dataset.wired) {
          samp.dataset.wired = '1';
          samp.addEventListener('click', async () => {
            try { localStorage.setItem(firstRunKey, '1'); } catch(_) {}
            try { await playSampleTrack(); } catch(e) { console.error('Failed to start sample', e); showToast('Sample unavailable', true); return; }
            hideStarter(); startRenderer();
          });
        }
      })();

      function hideStarter(){ try { starter.classList.remove('open'); starter.setAttribute('aria-hidden','true'); } catch(_) {} }
      function showStarter(){ try { starter.classList.add('open'); starter.setAttribute('aria-hidden','false'); } catch(_) {} }
      function syncAudioControls(mode, method){
        try {
          const audioModeSel = document.getElementById('settingAudioMode');
          const internalMethodSel = document.getElementById('settingInternalMethod');
          if (audioModeSel && typeof mode === 'string') audioModeSel.value = mode;
          if (internalMethodSel && typeof method === 'string') internalMethodSel.value = method;
        } catch(_) {}
      }
      function setMonitorEnabled(on){
        try { localStorage.setItem('monitorAudio', on ? '1' : '0'); } catch(_) {}
        try {
          if (tapNode && audioContext?.destination) {
            try { tapNode.disconnect(audioContext.destination); } catch(_) {}
            if (on && internalMethod !== 'tab') tapNode.connect(audioContext.destination);
          }
        } catch(_) {}
      }
      function closeAllPanels(except) {
        try { if (except !== 'settings') settingsPanel.classList.remove('open'); } catch(_) {}
        try { if (except !== 'playlist') playlistPanel.classList.remove('open'); } catch(_) {}
        try { if (except !== 'starter') document.getElementById('starter').classList.remove('open'); } catch(_) {}
      }
      const starterOpenBtn = document.getElementById('starterOpenBtn');
      if (starterOpenBtn) starterOpenBtn.addEventListener('click', () => {
        const s = document.getElementById('starter');
        const next = !(s && s.classList.contains('open'));
        closeAllPanels(next ? 'starter' : '');
        if (next) showStarter(); else hideStarter();
      });

      // Bottom bar chips removed; use top-bar Audio (starterOpenBtn)

      document.getElementById('micBtn').addEventListener('click', () => {
        if (micConnected) disconnectMic(true); else connectMic();
      });
      // Optional toggles stored in localStorage
      try {
        const rn = document.getElementById('settingRNNoise');
        if (rn) rn.addEventListener('change', (e) => localStorage.setItem('rnnoise', e.target.checked ? '1' : '0'));
        const sens = document.getElementById('settingMicSensitivity');
        if (sens) sens.addEventListener('input', (e) => localStorage.setItem('micSensitivity', String(e.target.value)));
      } catch(_) {}
      document.getElementById('uploadBtn').addEventListener('click', () => document.getElementById('fileInput').click());
      document.getElementById('fileInput').addEventListener('change', (e) => {
        if (e.target.files && e.target.files.length) {
          loadLocalFiles(e.target.files);
        }
      });
      document.getElementById('playBtn').addEventListener('click', () => {
        if (rendering) { stopRenderer(); showToast('Paused'); announce('Rendering paused'); }
        else { startRenderer(); showToast('Rendering started'); announce('Rendering started'); }
      });
      // Some buttons are not present; guard optional ones
      const prevBtn = document.getElementById('prevBtn');
      const nextBtn = document.getElementById('nextBtn');
      prevBtn?.addEventListener('click', () => prevPreset());
      nextBtn?.addEventListener('click', () => nextPreset());
      document.getElementById('nextArrowBtn').addEventListener('click', () => nextPreset());
      document.getElementById('backArrowBtn').addEventListener('click', () => prevPreset());

      document.getElementById('fullscreenBtn').addEventListener('click', () => {
        const el = document.getElementById('stage') || canvas;
        if (!document.fullscreenElement) {
          if (el.requestFullscreen) el.requestFullscreen();
        } else {
          if (document.exitFullscreen) document.exitFullscreen();
        }
      });

      document.getElementById('playlistBtn').addEventListener('click', () => {
        const next = !playlistPanel.classList.contains('open');
        closeAllPanels(next ? 'playlist' : '');
        if (next) playlistPanel.classList.add('open');
        announce(next ? 'Opened preset list' : 'Closed preset list');
      });
      // Quick dance toggle button
      const danceBtn = document.getElementById('danceBtn');
      if (danceBtn) {
        const applyDanceBtn = (on) => { try { on ? danceBtn.classList.add('dance-on') : danceBtn.classList.remove('dance-on'); } catch(_) {} };
        const storedDance = (localStorage.getItem('dancersOn') || '0') === '1';
        applyDanceBtn(storedDance);
        danceBtn.addEventListener('click', () => {
          const now = !(localStorage.getItem('dancersOn') === '1');
          try { localStorage.setItem('dancersOn', now ? '1' : '0'); } catch(_) {}
          try { window.Dancers && window.Dancers.enable(now); } catch(_) {}
          applyDanceBtn(now);
          showToast(`Dancing ${now ? 'enabled' : 'disabled'}`);
        });
      }
      // Playlist controls: hide disabled, reset
      const playlistPanelEl = document.getElementById('playlistPanel');
      if (playlistPanelEl) {
        // Header meta row
        const meta = document.createElement('div');
        meta.className = 'panel-meta';
        meta.innerHTML = '<div class="now">Now showing: <code id="presetNow">—</code></div><div class="count">(<span id="presetCount">0</span>)</div>';
        playlistPanelEl.insertBefore(meta, playlistPanelEl.querySelector('ul'));

        // Controls
        const controls = document.createElement('div');
        controls.className = 'panel-controls';
        // Search input
        const search = document.createElement('input');
        search.type = 'text'; search.id = 'presetSearch'; search.placeholder = 'Search presets…'; search.className = 'search';
        search.addEventListener('input', (e) => { presetSearchTerm = String(e.target.value || ''); buildPlaylist(); });
        controls.appendChild(search);

        const group = document.createElement('div'); group.className = 'group';
        const chipToggle = document.createElement('label'); chipToggle.className = 'chip-toggle'; chipToggle.title = 'Hide disabled presets';
        const hideCb = document.createElement('input'); hideCb.type = 'checkbox'; hideCb.checked = hideDisabled; hideCb.style.marginRight = '4px';
        chipToggle.appendChild(hideCb); chipToggle.appendChild(document.createTextNode('Hide disabled'));
        const resetBtn = document.createElement('button'); resetBtn.className = 'btn small secondary'; resetBtn.textContent = 'Reset disabled'; resetBtn.title = 'Enable all presets';
        resetBtn.addEventListener('click', () => { disabledSet = new Set(); saveDisabled(); buildPlaylist(); showToast('Disabled list cleared'); });
        hideCb.addEventListener('change', (e) => { hideDisabled = !!e.target.checked; localStorage.setItem('hideDisabled', hideDisabled ? '1' : '0'); buildPlaylist(); });
        group.appendChild(chipToggle); group.appendChild(resetBtn);
        controls.appendChild(group);

        playlistPanelEl.insertBefore(controls, playlistPanelEl.querySelector('ul'));
      }

      document.getElementById('settingsBtn').addEventListener('click', () => {
        const next = !settingsPanel.classList.contains('open');
        closeAllPanels(next ? 'settings' : '');
        if (next) settingsPanel.classList.add('open');
        announce(next ? 'Opened settings' : 'Closed settings');
      });
      // Progressive disclosure toggle
      const advBtn = document.getElementById('toggleAdvanced');
      if (advBtn) {
        const applyAdv = (on) => {
          if (on) { settingsPanel.classList.add('show-advanced'); advBtn.textContent = 'Hide advanced'; }
          else { settingsPanel.classList.remove('show-advanced'); advBtn.textContent = 'Show advanced'; }
          try { localStorage.setItem('showAdvanced', on ? '1' : '0'); } catch(_) {}
        };
        const storedAdv = (localStorage.getItem('showAdvanced') || '0') === '1';
        applyAdv(storedAdv);
        advBtn.addEventListener('click', () => { applyAdv(!settingsPanel.classList.contains('show-advanced')); });
      }
      // Scene shortcuts
      const bindScene = (id, fn) => { const el = document.getElementById(id); if (el) el.addEventListener('click', fn); };
      bindScene('sceneAnimals', async () => {
        try {
          // Prefer model: an animal head or creature
          const url = '../assets/models/animals/cow.obj';
          if (visualizer?.loadModelWithTransition) {
            await visualizer.loadModelWithTransition(url, { sampleEvery: 3, blendTime: 1.5 });
          }
          visualizer.setModelEffectsEnabled?.(true);
          visualizer.setModelOnlyMode?.(false);
          visualizer.applyVibe?.('nature_doc');
          showToast('Scene: Animals');
        } catch(_) { showToast('Animals scene failed', true); }
      });
      bindScene('sceneWater', () => {
        try {
          // Water vibe: cool colors, increased tonemap and subtle zoom
          visualizer.setModelEffectsEnabled?.(false);
          visualizer.setPostFX?.({ tonemap: 0.9, exposure: 0.05, saturation: -0.05, tint: [0.92,1.05,1.08] });
          showToast('Scene: Water');
        } catch(_) { showToast('Water scene failed', true); }
      });
      bindScene('sceneBeach', () => {
        try {
          visualizer.setModelEffectsEnabled?.(false);
          visualizer.applyVibe?.('sunset_beach');
          showToast('Scene: Beach');
        } catch(_) { showToast('Beach scene failed', true); }
      });
      bindScene('sceneParty', () => {
        try {
          visualizer.setModelEffectsEnabled?.(true);
          visualizer.configureParticles?.({ maxCount: 1200 });
          visualizer.setPostFX?.({ saturation: 0.25, contrast: 0.12, grain: 0.18, tint: [1.02,1.0,1.08] });
          showToast('Scene: Party');
        } catch(_) { showToast('Party scene failed', true); }
      });
      // Cinematic FX toggles
      const fxBloom = document.getElementById('fxBloom');
      const fxBassShake = document.getElementById('fxBassShake');
      const fxZoomBounce = document.getElementById('fxZoomBounce');
      const fxCameraShots = document.getElementById('fxCameraShots');
      const fxQuant = document.getElementById('fxQuantize');
      const fxAutoVibe = document.getElementById('fxAutoVibe');
      const fxVibeBars = document.getElementById('fxVibeBars');
      const fxBloomStrength = document.getElementById('fxBloomStrength');
      const fxShakeFreq = document.getElementById('fxShakeFreq');
      const fxShakeZoom = document.getElementById('fxShakeZoom');
      const fxBounceFreq = document.getElementById('fxBounceFreq');
      const reduceMotionCb = document.getElementById('settingReduceMotion');

      const applyFx = _.throttle(() => {
        if (!visualizer) return;
        // Gates
        if (visualizer.renderer) {
          visualizer.renderer.fxGate = visualizer.renderer.fxGate || { bloom: true, bassShake: true, zoomBounce: true, cameraShots: true };
          if (fxBloom) visualizer.renderer.fxGate.bloom = !!fxBloom.checked;
          if (fxBassShake) visualizer.renderer.fxGate.bassShake = !!fxBassShake.checked;
          if (fxZoomBounce) visualizer.renderer.fxGate.zoomBounce = !!fxZoomBounce.checked;
          if (fxCameraShots) visualizer.renderer.fxGate.cameraShots = !!fxCameraShots.checked;
        }
        // Strengths
        visualizer.renderer?.setPostFX?.({
          bassShake: (fxBassShake?.checked ? Math.max(0, Math.min(0.6, parseFloat(fxBloomStrength?.value || '0.0'))) : 0),
          bassShakeFreq: Math.max(0.1, parseFloat(fxShakeFreq?.value || '2.0')),
          bassShakeZoom: Math.max(0.0, parseFloat(fxShakeZoom?.value || '0.05')),
          zoomBounce: (fxZoomBounce?.checked ? 0.35 : 0.0),
          zoomBounceFreq: Math.max(0.1, parseFloat(fxBounceFreq?.value || '1.5')),
        });
        // Quantize & auto vibes
        const bars = Math.max(1, parseInt(fxVibeBars?.value || '4', 10));
        visualizer.renderer?.setQuantizedTransitions?.(!!fxQuant?.checked, bars);
        visualizer.renderer?.enableAutoVibes?.(!!fxAutoVibe?.checked, bars);

        // Persist
        try {
          localStorage.setItem('fxBloom', fxBloom?.checked ? '1' : '0');
          localStorage.setItem('fxBloomStrength', String(fxBloomStrength?.value || '0.4'));
          localStorage.setItem('fxBassShake', fxBassShake?.checked ? '1' : '0');
          localStorage.setItem('fxShakeFreq', String(fxShakeFreq?.value || '2.5'));
          localStorage.setItem('fxShakeZoom', String(fxShakeZoom?.value || '0.06'));
          localStorage.setItem('fxZoomBounce', fxZoomBounce?.checked ? '1' : '0');
          localStorage.setItem('fxCameraShots', fxCameraShots?.checked ? '1' : '0');
          localStorage.setItem('fxBounceFreq', String(fxBounceFreq?.value || '1.6'));
          localStorage.setItem('fxQuantize', fxQuant?.checked ? '1' : '0');
          localStorage.setItem('fxAutoVibe', fxAutoVibe?.checked ? '1' : '0');
          localStorage.setItem('fxVibeBars', String(fxVibeBars?.value || '4'));
        } catch(_) {}
      }, 100);

      [fxBloom, fxBassShake, fxZoomBounce, fxCameraShots, fxQuant, fxAutoVibe, fxVibeBars, fxBloomStrength, fxShakeFreq, fxShakeZoom, fxBounceFreq]
        .forEach((el) => el && el.addEventListener('change', applyFx));

      // Restore persisted FX values
      try {
        if (fxBloom) fxBloom.checked = (localStorage.getItem('fxBloom') || '1') === '1';
        if (fxBloomStrength) fxBloomStrength.value = String(localStorage.getItem('fxBloomStrength') || '0.4');
        if (fxBassShake) fxBassShake.checked = (localStorage.getItem('fxBassShake') || '0') === '1';
        if (fxShakeFreq) fxShakeFreq.value = String(localStorage.getItem('fxShakeFreq') || '2.5');
        if (fxShakeZoom) fxShakeZoom.value = String(localStorage.getItem('fxShakeZoom') || '0.035');
        if (fxZoomBounce) fxZoomBounce.checked = (localStorage.getItem('fxZoomBounce') || '1') === '1';
        if (fxCameraShots) fxCameraShots.checked = (localStorage.getItem('fxCameraShots') || '1') === '1';
        if (fxBounceFreq) fxBounceFreq.value = String(localStorage.getItem('fxBounceFreq') || '1.3');
        if (fxQuant) fxQuant.checked = (localStorage.getItem('fxQuantize') || '1') === '1';
        if (fxAutoVibe) fxAutoVibe.checked = (localStorage.getItem('fxAutoVibe') || '1') === '1';
        if (fxVibeBars) fxVibeBars.value = String(localStorage.getItem('fxVibeBars') || '4');
      } catch(_) {}

      // Reduce motion handling
      if (reduceMotionCb) {
        const storedRM = (localStorage.getItem('reduceMotion') || '0') === '1';
        reduceMotionCb.checked = storedRM;
        const applyReduceMotion = (enabled) => {
          if (!visualizer?.renderer) return;
          if (enabled) {
            if (fxBassShake) fxBassShake.checked = false;
            if (fxZoomBounce) fxZoomBounce.checked = false;
            visualizer.renderer.setPostFX?.({ bassShake: 0, zoomBounce: 0 });
          }
          try { localStorage.setItem('reduceMotion', enabled ? '1' : '0'); } catch(_) {}
          document.body.setAttribute('data-reduce-motion', enabled ? '1' : '0');
          applyFx();
          showToast(`Reduce motion ${enabled ? 'enabled' : 'disabled'}`);
        };
        reduceMotionCb.addEventListener('change', (e) => applyReduceMotion(!!e.target.checked));
        if (storedRM) applyReduceMotion(true); else applyFx();
      } else {
        applyFx();
      }


      document.getElementById('settingCycle').addEventListener('change', (e) => {
        presetCycle = e.target.checked;
        restartCycleInterval();
        showToast(`Cycle ${presetCycle ? 'enabled' : 'disabled'}`);
      });
      document.getElementById('settingRandom').addEventListener('change', (e) => {
        presetRandom = e.target.checked;
        showToast(`Random ${presetRandom ? 'enabled' : 'disabled'}`);
      });
      document.getElementById('settingCycleLen').addEventListener('change', (e) => {
        const v = parseInt(e.target.value, 10);
        if (!Number.isNaN(v) && v > 0) {
          presetCycleLength = v * 1000;
          restartCycleInterval();
          showToast(`Cycle length set to ${v}s`);
        }
      });

      // Backend controls
      const backendSel = document.getElementById('settingBackend');
      const directCb = document.getElementById('settingDirect');
      const wgpuModeSel = document.getElementById('settingWgpuMode');
      const wgpuEffectSel = document.getElementById('settingWgpuEffect');
      const wgpuP1El = document.getElementById('settingWgpuP1');
      const particleCb = document.getElementById('settingParticles');
      const particleNum = document.getElementById('settingParticleCount');
      const monitorCb = document.getElementById('settingMonitor');
      const audioModeSel = document.getElementById('settingAudioMode');
      const internalMethodSel = document.getElementById('settingInternalMethod');
      const grooveSel = document.getElementById('settingGroove');
      const modelFxCb = document.getElementById('settingModelEffects');
      const modelOnlyCb = document.getElementById('settingModelOnly');
      if (backendSel) {
        const stored = localStorage.getItem('backendPref') || 'auto';
        backendSel.value = stored;
        backendSel.addEventListener('change', () => { reinitVisualizer(); });
      }
      if (directCb) {
        const storedD = (localStorage.getItem('directDraw') || '0') === '1';
        directCb.checked = storedD;
        directCb.addEventListener('change', () => { reinitVisualizer(); });
      }
      // WebGPU controls
      if (wgpuModeSel) {
        const stored = localStorage.getItem('wgpuMode') || 'off';
        wgpuModeSel.value = stored;
        wgpuModeSel.addEventListener('change', (e) => { localStorage.setItem('wgpuMode', e.target.value); reinitVisualizer(); });
      }
      if (wgpuEffectSel) {
        const stored = localStorage.getItem('wgpuEffect') || 'pulsebloom';
        wgpuEffectSel.value = stored;
        wgpuEffectSel.addEventListener('change', (e) => { localStorage.setItem('wgpuEffect', e.target.value); reinitVisualizer(); });
      }
      if (wgpuP1El) {
        const stored = localStorage.getItem('wgpuP1') || '0.5';
        wgpuP1El.value = stored;
        wgpuP1El.addEventListener('change', (e) => { localStorage.setItem('wgpuP1', String(e.target.value || '0.5')); reinitVisualizer(); });
      }
      if (particleCb) {
        const pOn = (localStorage.getItem('particlesOn') || '0') === '1';
        particleCb.checked = pOn;
        particleCb.addEventListener('change', (e) => {
          localStorage.setItem('particlesOn', e.target.checked ? '1' : '0');
          visualizer.setParticlesEnabled?.(e.target.checked);
          showToast(`Particles ${e.target.checked ? 'enabled' : 'disabled'}`);
        });
      }
      if (particleNum) {
        particleNum.value = String(parseInt(localStorage.getItem('particlesCount') || '600', 10));
        particleNum.addEventListener('change', (e) => {
          const val = Math.max(0, Math.min(5000, parseInt(e.target.value || '0', 10)));
          localStorage.setItem('particlesCount', String(val));
          visualizer.configureParticles?.({ maxCount: val });
          showToast(`Particles: ${val}`);
        });
      }
      // New presets only
      (function wireNewPresets(){
        const cb = document.getElementById('settingNewPresetsOnly');
        if (!cb) return;
        const stored = (localStorage.getItem('newPresetsOnly') || '0') === '1';
        cb.checked = stored;
        cb.addEventListener('change', async (e) => {
          const on = !!e.target.checked; try { localStorage.setItem('newPresetsOnly', on ? '1' : '0'); } catch(_) {}
          await rebuildPresets(on);
          buildPlaylist();
          showToast(on ? 'New preset pack enabled' : 'All presets');
        });
      })();
      if (monitorCb) {
        const storedM = (localStorage.getItem('monitorAudio') || '1') === '1';
        monitorCb.checked = storedM;
        monitorCb.addEventListener('change', (e) => {
          localStorage.setItem('monitorAudio', e.target.checked ? '1' : '0');
          // Rehook tap routing
          try {
            if (tapNode) {
              tapNode.disconnect();
              tapNode.connect(analyser);
              // Never monitor tab capture to avoid duplicate playback
              const allow = e.target.checked && internalMethod !== 'tab';
              if (allow && audioContext?.destination) tapNode.connect(audioContext.destination);
            }
          } catch (_) {}
          showToast(`Monitor ${e.target.checked ? 'on' : 'off'}`);
        });
      }
      if (audioModeSel) {
        const storedMode = localStorage.getItem('audioMode') || 'internal';
        audioModeSel.value = storedMode;
        audioModeSel.addEventListener('change', (e) => {
          const mode = e.target.value;
          applyAudioMode(mode);
          // Inform renderer about mic amplification bias
          if (visualizer?.renderer?.setMicActive) {
            visualizer.renderer.setMicActive(mode === 'mic' || mode === 'both', mode === 'mic' ? 1.8 : 1.5);
          }
        });
        setTimeout(() => {
          applyAudioMode(storedMode);
          if (visualizer?.renderer?.setMicActive) {
            visualizer.renderer.setMicActive(storedMode === 'mic' || storedMode === 'both', storedMode === 'mic' ? 1.8 : 1.5);
          }
        }, 0);
      }
      if (internalMethodSel) {
        const storedIm = localStorage.getItem('internalMethod') || 'auto';
        internalMethodSel.value = storedIm;
        internalMethodSel.addEventListener('change', (e) => {
          internalMethod = e.target.value;
          localStorage.setItem('internalMethod', internalMethod);
          showToast(`Internal source: ${internalMethod}`);
          if (internalMethod === 'tab' && (audioModeSel?.value === 'internal' || audioModeSel?.value === 'both')) {
            if (!tabCaptureStarting && !tabStream) startTabAudioCapture();
          }
        });
      }
      if (modelFxCb) {
        const stored = (localStorage.getItem('modelFx') || '0') === '1';
        modelFxCb.checked = stored;
        if (visualizer?.setModelEffectsEnabled) visualizer.setModelEffectsEnabled(stored);
        modelFxCb.addEventListener('change', (e) => {
          localStorage.setItem('modelFx', e.target.checked ? '1' : '0');
          if (visualizer?.setModelEffectsEnabled) visualizer.setModelEffectsEnabled(e.target.checked);
          showToast(`Model effects ${e.target.checked ? 'enabled' : 'disabled'}`);
        });
      }
      if (modelOnlyCb) {
        const stored = (localStorage.getItem('modelOnly') || '0') === '1';
        modelOnlyCb.checked = stored;
        if (visualizer?.setModelOnlyMode) visualizer.setModelOnlyMode(stored);
        modelOnlyCb.addEventListener('change', (e) => {
          localStorage.setItem('modelOnly', e.target.checked ? '1' : '0');
          if (visualizer?.setModelOnlyMode) visualizer.setModelOnlyMode(e.target.checked);
          showToast(`Mode: ${e.target.checked ? 'Model-only' : 'Mixed'}`);
        });
      }
      // Dancers toggle (settings)
      (function wireDancersToggle(){
        const dancersCb = document.getElementById('settingDancers');
        if (!dancersCb) return;
        const stored = (localStorage.getItem('dancersOn') || '0') === '1';
        dancersCb.checked = stored;
        try { window.Dancers && window.Dancers.enable(stored); } catch(_) {}
        const syncBtn = (on) => { try { const btn = document.getElementById('danceBtn'); if (btn) { on ? btn.classList.add('dance-on') : btn.classList.remove('dance-on'); } } catch(_) {} };
        syncBtn(stored);
        dancersCb.addEventListener('change', (e) => {
          const on = !!e.target.checked;
          try { localStorage.setItem('dancersOn', on ? '1' : '0'); } catch(_) {}
          try { window.Dancers && window.Dancers.enable(on); } catch(_) {}
          syncBtn(on);
          showToast(`Dancing ${on ? 'enabled' : 'disabled'}`);
        });
      })();
      if (grooveSel) {
        const storedG = localStorage.getItem('groove') || 'light_swing';
        grooveSel.value = storedG;
        const applyGroove = (g) => {
          try {
            visualizer?.renderer?.setMomentConfig?.({ groove: g });
            showToast(`Groove: ${g.replace('_', ' ')}`);
          } catch(_) {}
        };
        grooveSel.addEventListener('change', (e) => {
          const g = e.target.value;
          localStorage.setItem('groove', g);
          applyGroove(g);
        });
        // apply at init
        setTimeout(() => applyGroove(storedG), 0);
      }

      // Sync offset controls
      const offsetRange = document.getElementById('settingOffsetRange');
      const offsetNum = document.getElementById('settingOffsetNum');
      if (offsetRange && offsetNum) {
        offsetRange.value = String(userSyncOffsetMs);
        offsetNum.value = String(userSyncOffsetMs);
        const apply = (val) => {
          userSyncOffsetMs = Math.max(-200, Math.min(200, parseInt(val || '0', 10)));
          localStorage.setItem('syncOffsetMs', String(userSyncOffsetMs));
          offsetRange.value = String(userSyncOffsetMs);
          offsetNum.value = String(userSyncOffsetMs);
          showToast(`Sync offset ${userSyncOffsetMs} ms`);
          announce(`Sync offset ${userSyncOffsetMs} milliseconds`);
        };
        offsetRange.addEventListener('input', (e) => apply(e.target.value));
        offsetNum.addEventListener('change', (e) => apply(e.target.value));
      }

      // Keyboard shortcuts
      window.addEventListener('keydown', (e) => {
        if (e.target && ['INPUT', 'TEXTAREA'].includes(e.target.tagName)) return;
        if (e.code === 'Space') { if (rendering) stopRenderer(); else startRenderer(); e.preventDefault(); }
        if (e.code === 'ArrowRight') nextPreset();
        if (e.code === 'ArrowLeft') prevPreset();
        if (e.key.toLowerCase() === 'x') disableCurrentPreset();
        if (e.key.toLowerCase() === 'f') document.getElementById('fullscreenBtn').click();
        if (e.key.toLowerCase() === 'p') document.getElementById('playlistBtn').click();
        if (e.key.toLowerCase() === 's') document.getElementById('settingsBtn').click();
        if (e.key === 'Escape') {
          try { document.getElementById('settingsPanel').classList.remove('open'); } catch(_) {}
          try { document.getElementById('playlistPanel').classList.remove('open'); } catch(_) {}
          try { closeModal('packsModal'); } catch(_) {}
          try { closeModal('aboutModal'); } catch(_) {}
          try { closeModal('modelsModal'); } catch(_) {}
        }
      });

      // Drag & drop upload
      window.addEventListener('dragover', (e) => { e.preventDefault(); });
      window.addEventListener('drop', (e) => {
        e.preventDefault();
        const files = Array.from(e.dataTransfer?.files || []).filter(f => /^audio\//.test(f.type));
        if (files.length) { loadLocalFiles(files); showToast(`Loaded ${files.length} file(s)`); }
      });

      // Top bar actions
      // Extensions button opens Presets panel now
      document.getElementById('extensionsBtn').addEventListener('click', () => {
        try { document.getElementById('playlistPanel').classList.add('open'); } catch(_) {}
      });
      // Settings tabs wiring
      (function wireSettingsTabs(){
        const tabs = Array.from(document.querySelectorAll('#settingsPanel .tab'));
        function showTab(name){
          tabs.forEach(t=>{ if (t.dataset.tab === name) { t.classList.add('active'); t.setAttribute('aria-selected','true'); } else { t.classList.remove('active'); t.setAttribute('aria-selected','false'); } });
          const blocks = Array.from(document.querySelectorAll('#settingsPanel .tab-content, #settingsPanel > h4, #settingsPanel > .scene-grid, #settingsPanel > .setting-row, #settingsPanel > .row, #settingsPanel > .divider'));
          // Simple approach: hide all tab-content blocks not matching, keep headings inside each tab-content
          blocks.forEach(b=>{ if (b.classList.contains('tab-content')) { b.hidden = (b.dataset.tab !== name); } });
        }
        tabs.forEach(t => t.addEventListener('click', () => showTab(t.dataset.tab)));
        showTab('general');
      })();
      document.getElementById('aboutBtn').addEventListener('click', () => openModal('aboutModal'));
      const modelsBtn = document.getElementById('modelsBtn');
      if (modelsBtn) {
        modelsBtn.addEventListener('click', () => {
          if (!modelsIndex) {
            fetch('../assets/models/index.json', { cache: 'no-cache' })
              .then(r => r.ok ? r.json() : null)
              .then(j => { modelsIndex = j; renderModelsPanel(); openModal('modelsModal'); })
              .catch(() => { showToast('No models index found', true); });
          } else {
            renderModelsPanel();
            openModal('modelsModal');
          }
        });
      }
      // Kick off initialization after UI is ready so starter can decide mode
      (async () => {
        try {
          await initPlayer();
          // If starter already chosen a mode earlier, apply it immediately
          const storedMode = localStorage.getItem('audioMode') || 'internal';
          applyAudioMode(storedMode);
        } catch (e) {
          console.error('Visualizer init failed', e);
          showToast('Initialization failed', true);
          announce('Initialization failed');
        }
      })();
    });
    
    // Message bridge for iframe embedding
    window.addEventListener('message', async (event) => {
      const payload = event && event.data ? event.data : null;
      const reply = (msg) => { try { event.source && event.source.postMessage(msg, '*'); } catch(_) {} };
      if (!payload || !payload.type) return;
      switch (payload.type) {
        case 'viz:getSnapshot': {
          let url = '';
          try { url = (document.getElementById('canvas')?.toDataURL && document.getElementById('canvas').toDataURL('image/png')) || ''; } catch(_) {}
          reply({ type: 'viz:snapshot', dataUrl: url });
          break;
        }
        case 'viz:toggleMic': {
          try { if (micConnected) disconnectMic(true); else await connectMic(); } catch(_) {}
          reply({ type: 'viz:mic', on: !!micConnected });
          break;
        }
        case 'viz:applyVibe': {
          try { applyVibeKey(payload.key); } catch(_) {}
          break;
        }
        case 'viz:setEmbed': {
          try {
            const on = payload.value !== false ? true : false;
            if (on) document.body.classList.add('embed'); else document.body.classList.remove('embed');
          } catch(_) {}
          break;
        }
        default: break;
      }
    });
  </script>

  <style>
    :root {
      --bar-bg: #0f1115; /* darker, angular Cybertruck vibe */
      --bar-fg: #e5ecf5;
      --bar-fg-dim: #b7c2d4;
      --accent: #c0ff33; /* cyber green accent */
      --accent-cyan: #5dd6ff;
      --accent-magenta: #ff64c3;
      --font-display: "Barrio", system-ui;
      --font-body: "Inter", -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      --font-mono: "Fira Code", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      --glass-blur: 22px;
      --glass-bg1: rgba(255,255,255,0.16);
      --glass-bg2: rgba(255,255,255,0.08);
      --glass-stroke: rgba(255,255,255,0.22);
      --glass-glow: rgba(192,255,51,0.28);
      --water-blur: 28px;
      --water-tint1: rgba(180, 220, 255, 0.10);
      --water-tint2: rgba(120, 180, 255, 0.06);
      --bar-darken: 0;
      --panel-darken: 0;
    }

    html, body {
      height: 100%;
      margin: 0;
      background: #0a0b1e;
      color: var(--bar-fg);
      font-family: var(--font-body);
    }

    .barrio-regular { font-family: "Barrio", system-ui; font-weight: 400; font-style: normal; }

    /* Liquid glass bars */
    #topbar, #bottombar {
      position: fixed;
      left: 0;
      right: 0;
      background:
        linear-gradient(135deg, rgba(0,0,0, var(--bar-darken)), rgba(0,0,0, var(--bar-darken))),
        linear-gradient(135deg, var(--water-tint1), var(--water-tint2));
      backdrop-filter: blur(var(--water-blur)) saturate(180%);
      -webkit-backdrop-filter: blur(var(--water-blur)) saturate(180%);
      color: var(--bar-fg);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 16px;
      z-index: 5;
      box-shadow: 0 1px 0 rgba(255,255,255,0.04) inset, 0 -1px 0 rgba(255,255,255,0.04) inset, 0 8px 24px rgba(0,0,0,0.18);
      border: 1px solid rgba(255,255,255,0.08);
      isolation: isolate; /* ensure blend happens against bar background, not canvas */
    }
    #topbar, #bottombar { position: fixed; overflow: hidden; }
    #topbar::before, #bottombar::before,
    #settingsPanel::before, #playlistPanel::before,
    .modal-card::before, #toast::before, .busy-card::before {
      content: ""; position: absolute; inset: 0; pointer-events: none;
      background:
        radial-gradient(120% 60% at 10% -20%, rgba(255,255,255,0.28), rgba(255,255,255,0) 60%),
        radial-gradient(80% 50% at 120% 0%, rgba(255,255,255,0.16), rgba(255,255,255,0) 70%);
      mix-blend-mode: screen; opacity: 0.9;
    }
    #topbar::after, #bottombar::after,
    #settingsPanel::after, #playlistPanel::after,
    .modal-card::after, #toast::after, .busy-card::after {
      content: ""; position: absolute; inset: -20% -10%; pointer-events: none;
      background: conic-gradient(from 0deg at 50% 50%, rgba(255,255,255,0.08) 0 10%, rgba(255,255,255,0) 10% 100%);
      filter: blur(14px); opacity: 0.4; animation: caustics 18s linear infinite;
      mask-image: radial-gradient(120% 100% at 50% 50%, #000 40%, transparent 80%);
    }
    @keyframes caustics { to { transform: rotate(360deg) translate3d(0,0,0); } }

    #topbar { top: 0; height: 56px; }
    #bottombar { bottom: 0; height: 70px; }

    .brand {
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 700;
      font-size: 26px;
      font-family: var(--font-display);
      letter-spacing: .3px;
    }

    .brand .logo {
      width: 36px;
      height: 36px;
      border: 3px solid var(--accent);
      border-radius: 4px; /* angular */
      display: grid;
      place-items: center;
      color: var(--accent);
      font-size: 18px;
    }

    .top-actions i {
      font-size: 20px; margin-left: 18px; opacity: 0.9; cursor: pointer;
      transition: transform .12s ease, opacity .12s ease;
      color: #fff;
      display: inline-grid; place-items: center; padding: 4px; border-radius: 8px;
      /* Create local contrast bubble by inverting only the backdrop under the icon */
      backdrop-filter: invert(1) saturate(120%);
      -webkit-backdrop-filter: invert(1) saturate(120%);
      mix-blend-mode: normal;
    }
    .top-actions i:hover { opacity: 1; transform: translateY(-1px); }
    .gpu-badge { margin-left: 12px; padding: 4px 8px; border-radius: 8px; background: rgba(255,255,255,0.08); font-size: 12px; letter-spacing: .3px; font-family: var(--font-mono); }
    .gpu-badge.ok { background: rgba(80,200,120,0.22); }

    .bar-section {
      display: flex;
      align-items: center;
      gap: 18px;
    }

    .btn {
      min-width: 44px; height: 44px; padding: 0 12px;
      border-radius: 12px;
      background: linear-gradient(135deg, rgba(255,255,255,0.08), rgba(255,255,255,0.04));
      color: var(--bar-fg);
      border: 1px solid var(--glass-stroke);
      display: inline-flex; align-items: center; justify-content: center; gap: 8px; cursor: pointer;
      white-space: nowrap;
      box-shadow: 0 8px 24px rgba(0,0,0,0.25), inset 0 1px 0 rgba(255,255,255,0.18);
      backdrop-filter: blur(calc(var(--glass-blur) * 0.5)) saturate(140%);
      -webkit-backdrop-filter: blur(calc(var(--glass-blur) * 0.5)) saturate(140%);
      transition: transform .12s ease, box-shadow .12s ease, background .12s ease;
    }
    .btn:hover { transform: translateY(-1px) scale(1.02); box-shadow: 0 10px 28px rgba(0,0,0,0.28), 0 0 0 2px rgba(255,255,255,0.06) inset; }
    .btn:active { transform: translateY(1px) scale(0.99); }
    .btn i { font-size: 16px; color: #fff; display: inline-grid; place-items: center; padding: 2px; border-radius: 6px; backdrop-filter: invert(1) saturate(120%); -webkit-backdrop-filter: invert(1) saturate(120%); mix-blend-mode: normal; }
    .btn span { display: inline-block; max-width: 220px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    /* Premium small/secondary variants */
    .btn.small { width: auto; height: 32px; min-width: 36px; padding: 0 12px; border-radius: 10px; font-size: 12px; box-shadow: 0 6px 18px rgba(0,0,0,0.22), inset 0 1px 0 rgba(255,255,255,0.16); }
    .btn.secondary { background: linear-gradient(135deg, rgba(255,255,255,0.08), rgba(255,255,255,0.04)); border-color: rgba(255,255,255,0.14); }
    /* Calmer glass tuning */
    #topbar::before, #bottombar::before { filter: blur(calc(var(--glass-blur) * 0.7)); opacity: 0.9; }
    #topbar::after, #bottombar::after { opacity: 0.35; }
    /* Mode chip group */
    .mode-group { display: inline-flex; gap: 8px; background: linear-gradient(135deg, rgba(255,255,255,0.12), rgba(255,255,255,0.06)); border: 1px solid rgba(255,255,255,0.14); border-radius: 999px; padding: 4px; box-shadow: 0 10px 24px rgba(0,0,0,0.28), inset 0 1px 0 rgba(255,255,255,0.16); }
    .mode-chip { display: inline-flex; align-items: center; gap: 8px; height: 36px; padding: 0 12px; border-radius: 999px; cursor: pointer; color: var(--bar-fg); background: transparent; border: 0; }
    .mode-chip i { font-size: 14px; }
    .mode-chip.active { background: linear-gradient(135deg, rgba(255,255,255,0.26), rgba(255,255,255,0.10)); box-shadow: inset 0 1px 0 rgba(255,255,255,0.22); }
    @media (max-width: 640px) { .mode-chip span { display: none; } }
    .btn.small.secondary { box-shadow: 0 6px 18px rgba(0,0,0,0.2), inset 0 1px 0 rgba(255,255,255,0.14); }
    /* Mic active state: greenish glow + inverted icon */
    .btn.mic-on {
      border-color: var(--accent);
      background:
        radial-gradient(120% 100% at 50% 0%, rgba(192,255,51,0.14), rgba(192,255,51,0.06)),
        linear-gradient(135deg, rgba(255,255,255,0.10), rgba(255,255,255,0.05));
      box-shadow:
        0 0 0 2px rgba(192,255,51,0.28),
        0 0 22px rgba(192,255,51,0.22),
        0 10px 26px rgba(0,0,0,0.24),
        inset 0 1px 0 rgba(255,255,255,0.22);
    }
    .btn.mic-on i { filter: invert(1) hue-rotate(120deg) saturate(1.2); }
    .btn:focus-visible { outline: 2px solid #5b8cff; outline-offset: 2px; }
    /* Dance active state: magenta/cyan glow */
    .btn.dance-on {
      border-color: var(--accent-magenta);
      background:
        radial-gradient(120% 100% at 50% 0%, rgba(255,100,195,0.16), rgba(255,100,195,0.08)),
        linear-gradient(135deg, rgba(255,255,255,0.10), rgba(255,255,255,0.05));
      box-shadow:
        0 0 0 2px rgba(255,100,195,0.28),
        0 0 22px rgba(255,100,195,0.22),
        0 10px 26px rgba(0,0,0,0.24),
        inset 0 1px 0 rgba(255,255,255,0.22);
    }
    .btn.dance-on i { filter: invert(1) hue-rotate(300deg) saturate(1.2); }

    #stage { position: fixed; inset: 0; }
    #canvas { position: absolute; inset: 0; width: 100%; height: 100%; background: #000; display: block; }
    /* Dancers overlay layer */
    #dancersLayer { position: absolute; inset: 56px 0 70px 0; pointer-events: none; z-index: 6; overflow: visible; perspective: 1200px; }
    body.embed #dancersLayer { inset: 0; }
    .dancer {
      position: absolute; will-change: transform, opacity, filter; pointer-events: none; transform-style: preserve-3d; backface-visibility: hidden;
      mix-blend-mode: screen; /* blend with visualization */
      --mx: 1; --sx: 0.9; --rot: 0deg; --ry: 0deg; --portalGlow: rgba(100,255,255,0.8);
      filter: drop-shadow(0 8px 24px rgba(0,0,0,0.35)) saturate(1.05);
      opacity: 0; transform: translate3d(0,0,0) rotateY(var(--ry)) scaleX(var(--mx)) scale(var(--sx)) rotate(var(--rot));
      animation: dancer-sway 6s ease-in-out infinite, dancer-color 14s linear infinite, dancer-warp 7s ease-in-out infinite;
      transition: filter .12s ease;
    }
    /* temporarily disable keyframe transforms to let CSS transitions control rotateY */
    .dancer.no-tx { animation: none; }
    .dancer.in { opacity: 1; transition: opacity .55s ease, transform .45s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
    .dancer.out { opacity: 0; transform: translate3d(0,0,0) rotateY(var(--ry)) scale(0.9); transition: opacity .45s ease, transform .5s ease; }
    .dancer.portal { filter: drop-shadow(0 0 12px var(--portalGlow)) saturate(1.28) brightness(1.12); }
    @keyframes dancer-sway { 0%{ transform: translateY(0) rotate(-2deg); } 50%{ transform: translateY(-8px) rotate(2deg); } 100%{ transform: translateY(0) rotate(-2deg); } }
    @keyframes dancer-color { 0%{ filter: drop-shadow(0 8px 24px rgba(0,0,0,0.35)) hue-rotate(0deg) saturate(1.05); } 50%{ filter: drop-shadow(0 8px 24px rgba(0,0,0,0.35)) hue-rotate(120deg) saturate(1.2); } 100%{ filter: drop-shadow(0 8px 24px rgba(0,0,0,0.35)) hue-rotate(360deg) saturate(1.05); } }
    @keyframes dancer-warp { 0%{ transform: translate3d(0,0,0) rotateY(var(--ry)) scaleX(var(--mx)) scale(var(--sx)) rotate(var(--rot)); } 50%{ transform: translate3d(0,0,0) rotateY(var(--ry)) scaleX(calc(var(--mx) * 1.02)) scale(calc(var(--sx) * 0.98)) rotate(calc(var(--rot) + 0.5deg)); } 100%{ transform: translate3d(0,0,0) rotateY(var(--ry)) scaleX(var(--mx)) scale(var(--sx)) rotate(var(--rot)); } }
    .portal-spark { position: absolute; width: 6px; height: 6px; border-radius: 999px; background: var(--portalGlow); box-shadow: 0 0 12px var(--portalGlow), 0 0 24px rgba(100,255,255,0.4); pointer-events: none; opacity: 0.95; animation: spark .6s ease-out forwards; }
    @keyframes spark { 0% { transform: translate(0,0) scale(0.8); opacity: 0.95; } 100% { transform: translate(var(--dx, 0px), var(--dy, 0px)) scale(0.4); opacity: 0; } }
    /* Embed mode hides chrome */
    body.embed #topbar,
    body.embed #bottombar,
    body.embed #settingsPanel,
    body.embed #playlistPanel,
    body.embed #hero { display: none !important; }

    #hero {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: grid;
      place-items: center;
      background: url('../preview.png') center/cover no-repeat;
      z-index: 3;
      text-align: center;
    }
    #hero.hidden { opacity: 0; pointer-events: none; transition: opacity .4s ease; }

    .hero-inner {
      transform: translateY(-8%);
      color: #ffeaa8;
      text-shadow: 0 2px 8px rgba(0,0,0,0.6);
    }
    .hero-title {
      font-size: 86px;
      margin: 18px 0 8px;
      font-weight: 800;
      font-family: var(--font-display);
    }
    .hero-subtitle {
      font-size: 40px;
      opacity: 0.95;
    }

    /* Panels */
    /* Liquid glass panels */
    #settingsPanel, #playlistPanel {
      position: fixed;
      bottom: 80px;
      right: 16px;
      background:
        linear-gradient(135deg, rgba(0,0,0, var(--panel-darken)), rgba(0,0,0, var(--panel-darken))),
        linear-gradient(135deg, rgba(255,255,255,0.14), rgba(255,255,255,0.06));
      backdrop-filter: blur(calc(var(--water-blur) * 0.9)) saturate(220%);
      -webkit-backdrop-filter: blur(calc(var(--water-blur) * 0.9)) saturate(220%);
      border: 1px solid rgba(255,255,255,0.16);
      border-radius: 12px;
      padding: 16px;
      width: clamp(280px, 38vw, 420px);
      max-height: 50vh;
      overflow: auto;
      transform: translateY(20px);
      opacity: 0;
      pointer-events: none;
      transition: all .2s ease;
      z-index: 10;
      color: var(--bar-fg);
      box-shadow: 0 16px 40px rgba(0,0,0,0.38), inset 0 1px 0 rgba(255,255,255,0.18);
    }
    .scene-grid { display:grid; grid-template-columns: repeat(4, minmax(0,1fr)); gap: 10px; margin: 10px 0 6px; }
    .scene-btn { display:flex; align-items:center; justify-content:center; gap:8px; padding:10px 12px; border-radius:12px; cursor:pointer; border: 1px solid var(--glass-stroke); background: linear-gradient(135deg, var(--glass-bg1), var(--glass-bg2)); box-shadow: 0 6px 18px rgba(0,0,0,0.18), inset 0 1px 0 rgba(255,255,255,0.16); color: var(--bar-fg); }
    .scene-btn:hover { box-shadow: 0 10px 26px rgba(0,0,0,0.24), inset 0 1px 0 rgba(255,255,255,0.20); transform: translateY(-1px); }
    .scene-btn i { font-size:16px; }
    #playlistPanel { right: 360px; width: clamp(320px, 48vw, 540px); }
    #settingsPanel.open, #playlistPanel.open { transform: translateY(0); opacity: 1; pointer-events: auto; }
    #settingsPanel h4, #playlistPanel h4 { margin: 0 0 10px; font-size: 16px; font-weight: 700; }

    .setting-row { display: grid; grid-template-columns: 28px 1fr auto; align-items: center; gap: 12px; margin: 10px 0; padding: 10px 12px; border-radius: 14px; background: linear-gradient(135deg, var(--glass-bg1), var(--glass-bg2)); border: 1px solid var(--glass-stroke); box-shadow: 0 10px 26px rgba(0,0,0,0.22), inset 0 1px 0 rgba(255,255,255,0.18); }
    .setting-row .icon { width: 28px; height: 28px; display: grid; place-items: center; border-radius: 8px; background: linear-gradient(135deg, rgba(255,255,255,0.18), rgba(255,255,255,0.06)); border: 1px solid var(--glass-stroke); color: var(--bar-fg); }
    .setting-row label { display: block; font-weight: 600; }
    .setting-row small { display: block; opacity: .75; font-size: 12px; font-weight: 400; }

    /* Liquid glass controls */
    #settingsPanel input[type="checkbox"] {
      appearance: none;
      -webkit-appearance: none;
      width: 46px; height: 26px; border-radius: 999px;
      background: linear-gradient(135deg, rgba(255,255,255,0.22), rgba(255,255,255,0.10));
      border: 1px solid var(--glass-stroke);
      position: relative; cursor: pointer;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.18), 0 6px 18px rgba(0,0,0,0.22);
      transition: background .15s ease, border-color .15s ease;
    }
    #settingsPanel input[type="checkbox"]::after {
      content: ""; position: absolute; top: 2px; left: 2px;
      width: 22px; height: 22px; border-radius: 50%;
      background: #fff; box-shadow: 0 2px 6px rgba(0,0,0,0.25);
      transition: transform .18s ease, background .15s ease;
    }
    #settingsPanel input[type="checkbox"]:checked {
      background: linear-gradient(135deg, rgba(192,255,51,0.65), rgba(192,255,51,0.35));
      border-color: rgba(192,255,51,0.7);
    }
    #settingsPanel input[type="checkbox"]:checked::after { transform: translateX(20px); background: #0a0b1e; }
    #settingsPanel input[type="checkbox"]:focus-visible { outline: 2px solid #5b8cff; outline-offset: 2px; }

    #settingsPanel select,
    #settingsPanel input[type="number"],
    #settingsPanel input[type="text"] {
      -webkit-appearance: none; appearance: none;
      background: linear-gradient(135deg, rgba(255,255,255,0.18), rgba(255,255,255,0.08));
      color: var(--bar-fg);
      border: 1px solid var(--glass-stroke);
      border-radius: 12px; min-height: 36px;
      padding: 8px 12px; box-shadow: inset 0 1px 0 rgba(255,255,255,0.18), 0 6px 18px rgba(0,0,0,0.18);
    }
    /* Premium select (global for modals too) */
    select {
      -webkit-appearance: none; appearance: none;
      background: linear-gradient(135deg, rgba(255,255,255,0.18), rgba(255,255,255,0.08));
      color: var(--bar-fg);
      border: 1px solid var(--glass-stroke);
      border-radius: 12px;
      min-height: 36px;
      padding: 8px 34px 8px 12px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.18), 0 6px 18px rgba(0,0,0,0.18);
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="%23e5ecf5"><path d="M7 10l5 5 5-5z"/></svg>');
      background-repeat: no-repeat; background-position: right 10px center; background-size: 12px;
    }
    select:focus-visible { outline: 2px solid #5b8cff; outline-offset: 2px; }
    /* Premium numeric input */
    input[type="number"] { background: linear-gradient(135deg, rgba(255,255,255,0.16), rgba(255,255,255,0.08)); border: 1px solid var(--glass-stroke); border-radius: 10px; min-height: 36px; padding: 6px 10px; box-shadow: inset 0 1px 0 rgba(255,255,255,0.18), 0 6px 16px rgba(0,0,0,0.16); }
    input[type="number"]:focus-visible { outline: 2px solid #5b8cff; outline-offset: 2px; }
    #settingsPanel select { cursor: pointer; padding-right: 34px;
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="%23e5ecf5"><path d="M7 10l5 5 5-5z"/></svg>');
      background-repeat: no-repeat; background-position: right 10px center; background-size: 12px; }
    #settingsPanel select:focus-visible,
    #settingsPanel input[type="number"]:focus-visible,
    #settingsPanel input[type="text"]:focus-visible { outline: 2px solid #5b8cff; outline-offset: 2px; }
    #settingsPanel input[type="number"]::-webkit-outer-spin-button,
    #settingsPanel input[type="number"]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    #settingsPanel input[type="number"] { appearance: textfield; -moz-appearance: textfield; width: 90px; }

    /* Range slider */
    #settingsPanel input[type="range"] { appearance: none; -webkit-appearance: none; width: 100%; height: 6px; border-radius: 999px; border: 1px solid var(--glass-stroke); background: linear-gradient(90deg, rgba(255,255,255,0.18), rgba(255,255,255,0.06)); box-shadow: inset 0 1px 0 rgba(255,255,255,0.18), 0 6px 18px rgba(0,0,0,0.18); }
    #settingsPanel input[type="range"]:focus-visible { outline: 2px solid #5b8cff; outline-offset: 2px; }
    #settingsPanel input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 18px; height: 18px; border-radius: 50%; background: var(--accent); border: 2px solid rgba(255,255,255,0.6); box-shadow: 0 2px 6px rgba(0,0,0,0.25); cursor: pointer; margin-top: -7px; }
    #settingsPanel input[type="range"]::-moz-range-thumb { width: 18px; height: 18px; border-radius: 50%; background: var(--accent); border: 2px solid rgba(255,255,255,0.6); box-shadow: 0 2px 6px rgba(0,0,0,0.25); cursor: pointer; }
    #settingsPanel input[type="range"]::-moz-range-track { height: 6px; border-radius: 999px; background: linear-gradient(90deg, rgba(255,255,255,0.18), rgba(255,255,255,0.06)); border: 1px solid var(--glass-stroke); }
    .setting-row input[type="number"] { width: 70px; }
    .setting-row:hover { box-shadow: 0 10px 28px rgba(0,0,0,0.24), inset 0 1px 0 rgba(255,255,255,0.20); }

    #presetList { list-style: none; padding: 0; margin: 0; }
    #presetList li { padding: 8px 10px; border-radius: 8px; cursor: pointer; display: flex; align-items: center; gap: 8px; }
    #presetList li:hover { background: rgba(255,255,255,0.06); }
    #presetList li.active { background: rgba(255,255,255,0.12); }
    #presetList li .title { flex: 1; min-width: 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    #presetList li.disabled .title { opacity: .55; text-decoration: line-through; }

    /* Playlist panel premium UI */
    #playlistPanel .panel-meta { display: flex; align-items: center; justify-content: space-between; gap: 8px; margin: 6px 0 10px; }
    #playlistPanel .panel-meta .now { font-weight: 700; opacity: .96; }
    #playlistPanel .panel-meta .now code { font-family: var(--font-mono); font-weight: 600; padding: 2px 6px; border-radius: 8px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.12); display: inline-block; max-width: 60vw; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; vertical-align: middle; }
    #playlistPanel .panel-meta .count { font-size: 12px; opacity: .8; }
    #playlistPanel .panel-controls { display: flex; align-items: center; justify-content: space-between; gap: 10px; margin: 8px 0; flex-wrap: wrap; }
    #playlistPanel .panel-controls .group { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
    #playlistPanel input[type="text"].search { width: 100%; min-height: 36px; border-radius: 10px; padding: 8px 12px; color: var(--bar-fg); background: linear-gradient(135deg, rgba(255,255,255,0.14), rgba(255,255,255,0.06)); border: 1px solid rgba(255,255,255,0.16); box-shadow: inset 0 1px 0 rgba(255,255,255,0.18), 0 6px 18px rgba(0,0,0,0.18); }
    #playlistPanel input[type="text"].search:focus-visible { outline: 2px solid #5b8cff; outline-offset: 2px; }
    /* Premium chip toggle (global) */
    .chip-toggle { display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; border-radius: 999px; background: linear-gradient(135deg, rgba(255,255,255,0.10), rgba(255,255,255,0.04)); border: 1px solid rgba(255,255,255,0.14); font-size: 12px; box-shadow: 0 6px 16px rgba(0,0,0,0.18), inset 0 1px 0 rgba(255,255,255,0.14); }
    .chip-toggle:hover { box-shadow: 0 8px 22px rgba(0,0,0,0.24), inset 0 1px 0 rgba(255,255,255,0.18); }
    .chip-toggle input[type="checkbox"] { width: 14px; height: 14px; accent-color: var(--accent); }
    #playlistPanel .chip-toggle { font-size: 12px; }
    #playlistPanel .btn.small { width: auto; height: 32px; padding: 0 12px; font-size: 12px; }
    #playlistPanel .btn.secondary { background: linear-gradient(135deg, rgba(255,255,255,0.08), rgba(255,255,255,0.04)); border-color: rgba(255,255,255,0.14); }
    @media (max-width: 640px) {
      #playlistPanel .panel-meta { flex-direction: column; align-items: flex-start; gap: 4px; }
      #playlistPanel .panel-controls { gap: 8px; }
      #playlistPanel .panel-controls .group { width: 100%; justify-content: space-between; }
    }

    /* Busy overlay */
    #busy {
      position: fixed; inset: 56px 0 70px 0; display: grid; place-items: center; background: rgba(8,9,24,0.35); color: var(--bar-fg); z-index: 9; opacity: 0; transition: opacity .2s ease; pointer-events: none;
    }
    .busy-card { background: linear-gradient(135deg, var(--water-tint1), var(--water-tint2)); backdrop-filter: blur(calc(var(--water-blur) * 0.6)); -webkit-backdrop-filter: blur(calc(var(--water-blur) * 0.6)); border: 1px solid rgba(255,255,255,0.12); border-radius: 16px; padding: 14px 16px; display: flex; align-items: center; gap: 10px; box-shadow: 0 18px 48px rgba(0,0,0,0.45); }
    .spinner { width: 18px; height: 18px; border: 3px solid rgba(255,255,255,0.25); border-top-color: var(--accent); border-radius: 50%; animation: spin 1s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Toast */
    #toast { position: fixed; left: 50%; bottom: 80px; transform: translateX(-50%); background: linear-gradient(135deg, var(--water-tint1), var(--water-tint2)); backdrop-filter: blur(calc(var(--water-blur) * 0.4)); -webkit-backdrop-filter: blur(calc(var(--water-blur) * 0.4)); color: var(--bar-fg); padding: 10px 14px; border-radius: 12px; opacity: 0; transition: opacity .15s ease, transform .15s ease; pointer-events: none; z-index: 11; border: 1px solid rgba(255,255,255,0.10); box-shadow: 0 16px 40px rgba(0,0,0,0.38); }

    /* Reduce motion -> disable shimmer */
    body[data-reduce-motion="1"] #topbar::after,
    body[data-reduce-motion="1"] #bottombar::after,
    body[data-reduce-motion="1"] #settingsPanel::after,
    body[data-reduce-motion="1"] #playlistPanel::after,
    body[data-reduce-motion="1"] .modal-card::after,
    body[data-reduce-motion="1"] #toast::after,
    body[data-reduce-motion="1"] .busy-card::after { display: none; }
    #toast.show { opacity: 1; transform: translateX(-50%) translateY(-4px); }
    #toast.error { background: rgba(160,30,30,0.95); }

    /* Starter overlay */
    #starter { position: fixed; inset: 56px 16px 70px 16px; z-index: 14; display: none; place-items: center; }
    #starter.open { display: grid; }
    .starter-card { width: min(94vw, 320px); background:
      linear-gradient(135deg, rgba(0,0,0, var(--panel-darken)), rgba(0,0,0, var(--panel-darken))),
      linear-gradient(135deg, rgba(255,255,255,0.16), rgba(255,255,255,0.06));
      border: 1px solid rgba(255,255,255,0.16); border-radius: 16px; color: var(--bar-fg); overflow: hidden; cursor: pointer;
      box-shadow: 0 22px 48px rgba(0,0,0,0.45), inset 0 1px 0 rgba(255,255,255,0.18);
      display: grid; grid-template-rows: 140px auto; text-align: left; transition: transform .15s ease, box-shadow .15s ease;
    }
    .starter-card:hover { transform: translateY(-2px); box-shadow: 0 26px 56px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.22); }
    .starter-cover { background-size: cover; background-position: center; border-bottom: 1px solid rgba(255,255,255,0.12); }
    .starter-body { padding: 12px; display: grid; gap: 6px; }
    .starter-title { font-weight: 700; font-size: 16px; }
    .starter-sub { font-size: 12px; opacity: .85; }
    .starter-grid { display: grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap: 16px; }
    .starter-wrap { width: min(1000px, 96vw); margin: 0 auto; text-align: center; }
    .starter-head { font-size: 18px; font-weight: 700; margin-bottom: 12px; opacity: .95; }
    .starter-note { font-size: 12px; opacity: .8; margin-top: 10px; }
    @media (max-width: 880px) { .starter-grid { grid-template-columns: 1fr; } }

    /* Level meter */
    .level-wrap { width: 120px; height: 6px; background: rgba(255,255,255,0.08); border-radius: 999px; overflow: hidden; }
    .level { height: 100%; width: 0%; background: linear-gradient(90deg, #5bff8a, #ffd76a); }

    /* Modal */
    .modal { position: fixed; inset: 0; display: grid; place-items: center; background: rgba(4,6,18,0.55); opacity: 0; pointer-events: none; transition: opacity .15s; z-index: 12; }
    .modal.open { opacity: 1; pointer-events: auto; }
    .modal-card { width: min(92vw, 520px); background:
      linear-gradient(135deg, rgba(0,0,0, var(--panel-darken)), rgba(0,0,0, var(--panel-darken))),
      linear-gradient(135deg, rgba(255,255,255,0.14), rgba(255,255,255,0.06)); backdrop-filter: blur(calc(var(--glass-blur) * 0.9)) saturate(220%); -webkit-backdrop-filter: blur(calc(var(--glass-blur) * 0.9)) saturate(220%); border: 1px solid rgba(255,255,255,0.16); border-radius: 16px; padding: 16px; color: var(--bar-fg); box-shadow: 0 22px 48px rgba(0,0,0,0.45), inset 0 1px 0 rgba(255,255,255,0.2); }
    .modal-card h3 { margin: 6px 0 12px; font-size: 18px; }
    .modal-actions { display:flex; justify-content:flex-end; gap: 8px; margin-top: 14px; }
    .chip { display:inline-block; padding: 6px 10px; border-radius: 999px; background: rgba(255,255,255,0.08); margin-right: 8px; font-size: 12px; }
    .row { display:flex; align-items:center; justify-content:space-between; gap: 12px; margin: 10px 0; }
    .row label { font-size: 14px; }
    .models-grid { display:grid; grid-template-columns: 1fr; gap: 8px; max-height: 40vh; overflow:auto; }
    .model-item { padding: 8px 10px; border:1px solid rgba(255,255,255,0.08); border-radius:8px; cursor:pointer; }
    .model-item:hover { background: rgba(255,255,255,0.06); }

    /* Responsive adjustments */
    @media (max-width: 840px) {
      .btn { min-width: 40px; height: 40px; padding: 0 10px; }
      .bar-section { gap: 12px; }
      #playlistPanel { right: 16px; }
    }
    @media (max-width: 640px) {
      #settingsPanel, #playlistPanel {
        left: 16px;
        right: 16px;
        width: auto;
        max-height: 55vh;
      }
      .setting-row { gap: 10px; }
      .setting-row label { font-size: 13px; }
      .hero-title { font-size: 54px; }
      .hero-subtitle { font-size: 24px; }
      .gpu-badge { display: none; }
    }
  </style>
  <style>
    /* Sidebar removed */
  </style>
  <style>
    /* Progressive disclosure for advanced rows */
    #settingsPanel .advanced { display: none; }
    #settingsPanel.show-advanced .advanced { display: flex; }
    .advanced-toggle { margin: 8px 0 12px; display: inline-block; font-size: 12px; opacity: .92; cursor: pointer; }
    .tabbar { display: flex; gap: 8px; align-items: center; }
    .tab { height: 32px; padding: 0 12px; border-radius: 999px; border: 1px solid rgba(255,255,255,0.14); background: linear-gradient(135deg, rgba(255,255,255,0.10), rgba(255,255,255,0.04)); color: var(--bar-fg); cursor: pointer; }
    .tab.active { background: linear-gradient(135deg, rgba(255,255,255,0.24), rgba(255,255,255,0.10)); box-shadow: inset 0 1px 0 rgba(255,255,255,0.20); }
  </style>
</head>
<body>
  <div id="topbar">
    <div class="brand">
      <div class="logo"><i class="fa-solid fa-compact-disc"></i></div>
      <div>Veed Sync</div>
    </div>
    <div class="top-actions">
      <i id="extensionsBtn" class="fa-solid fa-puzzle-piece" title="Preset packs"></i>
      <i id="aboutBtn" class="fa-regular fa-circle-question" title="About"></i>
      <i id="modelsBtn" class="fa-solid fa-cubes" title="Models"></i>
      <i id="starterOpenBtn" class="fa-solid fa-sliders" title="Audio mode"></i>
      <span id="gpuBadge" class="gpu-badge" title="Graphics backend">Detecting…</span>
    </div>
  </div>

  <div id="hero">
    <div class="hero-inner">
      <div class="logo" style="margin: 0 auto; width: 110px; height: 110px; border-width: 6px; font-size: 40px;"><i class="fa-solid fa-compact-disc"></i></div>
      <div class="hero-title">Veed Sync</div>
      <div class="hero-subtitle">music visualizer</div>
    </div>
  </div>

  <div id="stage">
    <canvas id="canvas"></canvas>
    <div id="dancersLayer" aria-hidden="true"></div>
  </div>

  <!-- Starter overlay -->
  <div id="starter" aria-hidden="true">
    <div class="starter-wrap">
      <div class="starter-head">Choose how to listen</div>
      <div class="starter-grid">
        <div id="starterDetect" class="starter-card" role="button" tabindex="0">
          <div class="starter-cover" style="background-image:url('https://images.unsplash.com/photo-1526470608268-f674ce90ebd4?q=80&w=1200&auto=format&fit=crop');"></div>
          <div class="starter-body">
            <div class="starter-title">Currently Playing Music Detection</div>
            <div class="starter-sub">Capture audio from this tab or system</div>
          </div>
        </div>
        <div id="starterMic" class="starter-card" role="button" tabindex="0">
          <div class="starter-cover" style="background-image:url('https://images.unsplash.com/photo-1511379938547-c1f69419868d?q=80&w=1200&auto=format&fit=crop');"></div>
          <div class="starter-body">
            <div class="starter-title">Mic Mode</div>
            <div class="starter-sub">Use your microphone for live input</div>
          </div>
        </div>
        <div id="starterSample" class="starter-card" role="button" tabindex="0">
          <div class="starter-cover" style="background-image:url('https://images.unsplash.com/photo-1483412033650-1015ddeb83d1?q=80&w=1200&auto=format&fit=crop');"></div>
          <div class="starter-body">
            <div class="starter-title">Sample Track: Atma Rama</div>
            <div class="starter-sub">Debosmita Deb, CHANDAN JAISWAL & Vickky Agarwal • 2025</div>
          </div>
        </div>
      </div>
      <div class="starter-note">You can change mode anytime in Settings.</div>
    </div>
  </div>

  <div id="bottombar">
    <div class="bar-section">
      <button id="micBtn" class="btn" title="Use Mic"><i class="fa-solid fa-microphone"></i></button>
      <button id="uploadBtn" class="btn" title="Load local files"><i class="fa-solid fa-cloud-arrow-up"></i></button>
      <div class="level-wrap" aria-hidden="true"><div id="level" class="level"></div></div>
    </div>
    <div class="bar-section">
      <button id="playlistBtn" class="btn" title="Presets"><i class="fa-solid fa-list"></i></button>
      <button id="playBtn" class="btn" title="Render"><i class="fa-solid fa-play"></i></button>
      <button id="nextBtn" class="btn" title="Next Preset"><i class="fa-solid fa-forward-step"></i></button>
    </div>
    <div class="bar-section">
      <button id="settingsBtn" class="btn" title="Settings"><i class="fa-solid fa-gear"></i></button>
      <button id="danceBtn" class="btn" title="Dancing vibe"><i class="fa-solid fa-person-dots-from-line"></i><span style="display:none">Dance</span></button>
      <button id="backArrowBtn" class="btn" title="Previous"><i class="fa-solid fa-arrow-left"></i></button>
      <button id="nextArrowBtn" class="btn" title="Next"><i class="fa-solid fa-arrow-right"></i></button>
      <button id="fullscreenBtn" class="btn" title="Fullscreen"><i class="fa-regular fa-square"></i></button>
    </div>
  </div>

  <!-- Sidebar removed -->

  <input id="fileInput" type="file" accept="audio/*" multiple style="display:none" />

  <div id="settingsPanel">
    <h4>Settings</h4>
    <div class="tabbar" role="tablist" aria-label="Settings tabs">
      <button class="tab active" data-tab="general" role="tab" aria-selected="true">General</button>
      <button class="tab" data-tab="visuals" role="tab">Visuals</button>
      <button class="tab" data-tab="motion" role="tab">Motion</button>
      <button class="tab" data-tab="audio" role="tab">Audio</button>
      <button class="tab" data-tab="advanced" role="tab">Advanced</button>
    </div>
    <div class="divider"></div>

    <h4 style="margin-top:10px">Scenes</h4>
    <div class="scene-grid">
      <button class="scene-btn" id="sceneAnimals" title="Animals"><i class="fa-solid fa-paw"></i><span>Animals</span></button>
      <button class="scene-btn" id="sceneWater" title="Water"><i class="fa-solid fa-water"></i><span>Water</span></button>
      <button class="scene-btn" id="sceneBeach" title="Beach"><i class="fa-solid fa-umbrella-beach"></i><span>Beach</span></button>
      <button class="scene-btn" id="sceneParty" title="Party"><i class="fa-solid fa-champagne-glasses"></i><span>Party</span></button>
    </div>

    <h4 style="margin-top:16px">Visuals</h4>
    <div class="setting-row"><div class="icon"><i class="fa-solid fa-burst"></i></div><div><label>Bass Bloom</label><small>Glowing amplification on kick transients</small></div><input id="fxBloom" type="checkbox" checked /></div>
    <div class="setting-row advanced"><div class="icon"><i class="fa-solid fa-sun"></i></div><div><label>Bloom strength</label><small>Intensity of glow</small></div><input id="fxBloomStrength" type="number" min="0" max="1" step="0.05" value="0.4" /></div>

    <h4 style="margin-top:16px">Motion</h4>
    <div class="setting-row"><div class="icon"><i class="fa-solid fa-video"></i></div><div><label>Cinematic shots</label><small>Occasional auto camera moves</small></div><input id="fxCameraShots" type="checkbox" checked /></div>
    <div class="setting-row"><div class="icon"><i class="fa-solid fa-wave-square"></i></div><div><label>Bass Shake</label><small>Subtle camera jiggle on bass</small></div><input id="fxBassShake" type="checkbox" checked /></div>
    <div class="setting-row advanced"><div class="icon"><i class="fa-solid fa-signal"></i></div><div><label>Shake freq (Hz)</label><small>How often the shake occurs</small></div><input id="fxShakeFreq" type="number" min="0.1" max="8" step="0.1" value="2.5" /></div>
    <div class="setting-row advanced"><div class="icon"><i class="fa-solid fa-magnifying-glass"></i></div><div><label>Shake zoom</label><small>Zoom amount during shake</small></div><input id="fxShakeZoom" type="number" min="0" max="0.2" step="0.005" value="0.06" /></div>
    <div class="setting-row"><div class="icon"><i class="fa-solid fa-arrows-to-circle"></i></div><div><label>Downbeat Bounce</label><small>Camera spring on downbeat</small></div><input id="fxZoomBounce" type="checkbox" checked /></div>
    <div class="setting-row advanced"><div class="icon"><i class="fa-solid fa-chart-line"></i></div><div><label>Bounce freq (Hz)</label><small>Spring oscillation frequency</small></div><input id="fxBounceFreq" type="number" min="0.1" max="3" step="0.1" value="1.6" /></div>

    <h4 style="margin-top:16px">Playback</h4>
    <div class="setting-row"><div class="icon"><i class="fa-solid fa-music"></i></div><div><label>Quantize transitions</label><small>Change on bar boundaries</small></div><input id="fxQuantize" type="checkbox" checked /></div>
    <div class="setting-row"><div class="icon"><i class="fa-solid fa-bars"></i></div><div><label>Bars per change</label><small>Number of bars between changes</small></div><input id="fxVibeBars" type="number" min="1" max="8" step="1" value="4" /></div>
    <div class="row"><label for="settingGroove">Groove</label>
      <select id="settingGroove">
        <option value="straight">Straight</option>
        <option value="light_swing" selected>Light Swing</option>
        <option value="heavy_swing">Heavy Swing</option>
      </select>
    </div>
    <div class="setting-row"><div class="icon"><i class="fa-solid fa-shuffle"></i></div><div><label for="settingCycle">Cycle presets</label><small>Auto-advance through styles</small></div><input id="settingCycle" type="checkbox" checked /></div>
    <div class="setting-row advanced"><div class="icon"><i class="fa-solid fa-timer"></i></div><div><label for="settingCycleLen">Cycle length (sec)</label><small>Time between changes</small></div><input id="settingCycleLen" type="number" min="1" value="15" /></div>
    <div class="setting-row"><div class="icon"><i class="fa-solid fa-dice"></i></div><div><label for="settingRandom">Random order</label><small>Shuffle presets instead of linear</small></div><input id="settingRandom" type="checkbox" checked /></div>

    <div class="divider"></div>
    <h4 style="margin-top:10px">Vibes</h4>
    <div class="setting-row"><div class="icon"><i class="fa-solid fa-person-dots-from-line"></i></div><div><label>Dancing GIFs</label><small>Overlay dancing characters, beat-reactive</small></div><input id="settingDancers" type="checkbox" /></div>

    <div class="row">
      <label for="settingBackend">Backend</label>
      <select id="settingBackend">
        <option value="auto">Auto</option>
        <option value="webgl2">WebGL2</option>
        <option value="webgpu">WebGPU (experimental)</option>
      </select>
    </div>
    <div class="row"><label for="settingDirect">Direct draw</label><input id="settingDirect" type="checkbox" /></div>
    <div class="row"><label for="settingWgpuMode">WebGPU mode</label>
      <select id="settingWgpuMode">
        <option value="off">Off</option>
        <option value="post" selected>Post</option>
        <option value="pure">Pure</option>
      </select>
    </div>
    <div class="row"><label for="settingWgpuEffect">WebGPU effect</label>
      <select id="settingWgpuEffect">
        <option value="pulsebloom" selected>PulseBloom</option>
        <option value="neonglitch">NeonGlitch</option>
        <option value="spectraltrails">SpectralTrails</option>
        <option value="vectorscope2d">VectorScope2D (pure)</option>
      </select>
    </div>
    <div class="row advanced"><label for="settingWgpuP1">Effect Param1</label>
      <input id="settingWgpuP1" type="number" min="0" max="1" step="0.05" value="0.5" />
    </div>
    <div class="row"><label for="settingAudioMode">Audio mode</label>
      <select id="settingAudioMode">
        <option value="internal">Internal</option>
        <option value="mic">Mic</option>
        <option value="both">Both</option>
      </select>
    </div>
    <div class="row"><label for="settingInternalMethod">Internal source</label>
      <select id="settingInternalMethod">
        <option value="auto">Auto</option>
        <option value="element">HTMLAudio</option>
        <option value="file">Local File</option>
        <option value="tab">Tab Capture</option>
      </select>
    </div>
    <div class="row"><label>Monitor audio</label><input id="settingMonitor" type="checkbox" checked /></div>

    <div class="row"><label>Particles</label><input id="settingParticles" type="checkbox" /></div>
    <div class="row advanced"><label>Count</label><input id="settingParticleCount" type="number" min="0" max="5000" step="50" value="600" /></div>

    <div class="row"><label>Model Effects</label><input id="settingModelEffects" type="checkbox" /></div>
    <div class="row"><label>Model Only</label><input id="settingModelOnly" type="checkbox" /></div>

    <div class="row"><label>Reduce motion</label><input id="settingReduceMotion" type="checkbox" /></div>
    <div class="row"><label>Show only new presets</label><input id="settingNewPresetsOnly" type="checkbox" /></div>
  </div>

  <div id="playlistPanel">
    <h4>Presets</h4>
    <div class="panel-controls">
      <div class="group">
        <label class="chip-toggle"><input type="checkbox" id="chipBase" checked>Base</label>
        <label class="chip-toggle"><input type="checkbox" id="chipExtra" checked>Extra</label>
        <label class="chip-toggle"><input type="checkbox" id="chipNewOnly">New only</label>
      </div>
      <input type="text" id="presetSearch" class="search" placeholder="Search presets…" />
    </div>
    <ul id="presetList"></ul>
  </div>

  <div id="busy" role="alert" aria-live="polite" aria-hidden="true">
    <div class="busy-card">
      <div class="spinner"></div>
      <div class="busy-label">Working…</div>
    </div>
  </div>

  <div id="toast" role="status" aria-live="polite"></div>
  <div id="live" class="sr-only" aria-live="polite" style="position:absolute;left:-9999px;top:auto;width:1px;height:1px;overflow:hidden;">Ready</div>

  <!-- Packs Modal removed in favor of chips inside Presets panel -->

  <!-- About Modal -->
  <div id="aboutModal" class="modal" aria-hidden="true">
    <div class="modal-card">
      <h3>About Veed Sync</h3>
      <div style="font-size:14px;opacity:.92;line-height:1.5">
        Real‑time WebGL visualizer. Mic and local audio supported. Presets courtesy of the community.
      </div>
      <div style="margin-top:10px;">
        <span class="chip">GPU: <span id="aboutGpu">detecting…</span></span>
        <span class="chip">WebGPU: <span id="aboutWebgpu">checking…</span></span>
      </div>
      <div style="margin-top:10px;font-size:12px;opacity:.85;font-family: var(--font-mono);">
        Shortcuts: Space (Play/Pause), ←/→ (Prev/Next), F (Fullscreen), P (Presets), S (Settings), X (Disable), Esc (Close)
      </div>
      <div class="modal-actions">
        <button class="btn" onclick="document.getElementById('aboutModal').classList.remove('open')">Close</button>
      </div>
    </div>
  </div>

  <!-- Models Modal -->
  <div id="modelsModal" class="modal" aria-hidden="true">
    <div class="modal-card">
      <h3>Models</h3>
      <div class="row">
        <label for="modelsCategory">Category</label>
        <select id="modelsCategory" style="min-width: 180px;"></select>
      </div>
      <div class="row">
        <label for="modelsSample">Sample every (vertices)</label>
        <input id="modelsSample" type="number" min="1" max="16" step="1" value="3" />
      </div>
      <div class="row">
        <label for="modelsBlend">Blend time (sec)</label>
        <input id="modelsBlend" type="number" min="0" max="10" step="0.1" value="1.5" />
      </div>
      <div class="row">
        <label for="modelsPreload">Save as preload</label>
        <input id="modelsPreload" type="checkbox" />
      </div>
      <div id="modelsList" class="models-grid"></div>
      <div class="modal-actions">
        <button class="btn" onclick="document.getElementById('modelsModal').classList.remove('open')">Close</button>
      </div>
    </div>
  </div>
</body>


