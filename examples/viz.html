<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Veed Sync</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="stylesheet" href="https://unpkg.com/normalize.css/normalize.css" />
  <link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.5.2/css/all.min.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Barrio&family=Inter:wght@300..900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400..700&display=swap" rel="stylesheet">

  <script type="text/javascript" src="https://unpkg.com/lodash"></script>
  <script type="text/javascript" src="https://unpkg.com/butterchurn-presets@3.0.0-beta.4/dist/base.min.js"></script>
  <script type="text/javascript" src="https://unpkg.com/butterchurn-presets@3.0.0-beta.4/dist/extra.min.js"></script>
  <script type="module">
    import veedSync from '../dist/veed-sync.min.js';

    let visualizer = null;
    let rendering = false;
    let rafId = 0;
    let audioContext = null;
    let sourceNode = null;
    // Unified tap feeding both destination and analysis/visualizer
    let tapNode = null;
    let internalMethod = localStorage.getItem('internalMethod') || 'auto'; // auto | tab | element
    let tabStream = null;
    let htmlAudioEl = null;
    // Mic chain references
    let micStream = null;
    let micSourceNode = null;
    let micGainNode = null;
    let micConnected = false;
    let internalConnected = false;
    let cycleInterval = null;
    let presets = {};
    let presetKeys = [];
    let presetIndexHist = [];
    let presetIndex = 0;
    let presetCycle = true;
    let presetCycleLength = 15000;
    let presetRandom = true;
    let disabledSet = new Set();
    let hideDisabled = (localStorage.getItem('hideDisabled') || '0') === '1';
    let presetSearchTerm = '';

    let canvas; // assigned on DOMContentLoaded
    let hero;
    let settingsPanel;
    let playlistPanel;
    let busy;
    let toast;
    let live;
    let level;
    let gpuBadge;
    let analyser = null;
    let levelArray = null;
    let userSyncOffsetMs = Number(localStorage.getItem('syncOffsetMs') || '0');
    let modelsIndex = null;
    let pendingTapConnect = false;
    let includeClassicLocal = (localStorage.getItem('classicLocal') || '1') === '1';
    let embedMode = false;

    function openModal(id) {
      const el = document.getElementById(id);
      if (el) { el.classList.add('open'); el.setAttribute('aria-hidden', 'false'); }
    }
    function closeModal(id) {
      const el = document.getElementById(id);
      if (el) { el.classList.remove('open'); el.setAttribute('aria-hidden', 'true'); }
    }

    function renderModelsPanel() {
      const catSel = document.getElementById('modelsCategory');
      const list = document.getElementById('modelsList');
      if (!catSel || !list) return;
      catSel.innerHTML = '';
      const cats = Object.keys(modelsIndex || {});
      cats.forEach((c) => {
        const opt = document.createElement('option');
        opt.value = c; opt.textContent = c; catSel.appendChild(opt);
      });
      const drawList = () => {
        list.innerHTML = '';
        const cat = catSel.value || cats[0];
        const items = (modelsIndex && modelsIndex[cat]) || [];
        items.forEach((it) => {
          const div = document.createElement('div');
          div.className = 'model-item';
          div.textContent = `${it.name}`;
          div.title = it.file;
          div.addEventListener('click', async () => {
            const sample = Math.max(1, parseInt(document.getElementById('modelsSample').value || '3', 10));
            const blend = Math.max(0, parseFloat(document.getElementById('modelsBlend').value || '1.5'));
            const preload = document.getElementById('modelsPreload').checked;
            const url = it.file.startsWith('http') ? it.file : ('../' + it.file.replace(/^\.?\/?/, ''));
            try {
              if (visualizer.loadModelWithTransition) {
                await visualizer.loadModelWithTransition(url, { sampleEvery: sample, blendTime: blend });
              } else if (visualizer.loadParticleModelFromURL) {
                await visualizer.loadParticleModelFromURL(url, { sampleEvery: sample, enabled: true });
              } else {
                throw new Error('Model loading not supported in this build');
              }
              visualizer.setModelEffectsEnabled(true);
              if (preload) localStorage.setItem('modelURL', url);
              showToast(`Loaded model: ${it.name}`);
            } catch (e) {
              console.error('Failed to load model', e);
              showToast(`Model load failed: ${e?.message || 'error'}`, true);
            }
          });
          list.appendChild(div);
        });
      };
      catSel.addEventListener('change', drawList);
      catSel.value = cats[0] || '';
      drawList();
    }
    function hideHero() {
      hero.classList.add('hidden');
    }

    function ensureAudioContext() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      return audioContext;
    }

    function connectToAudioTap(node) {
      ensureAudioContext();
      if (!tapNode) {
        tapNode = audioContext.createGain();
        tapNode.gain.value = 1.0;
        // Create analyser once and keep connected
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048;
        levelArray = new Uint8Array(analyser.frequencyBinCount);
        tapNode.connect(analyser);
        // Route to destination based on monitor toggle
        const monitor = (localStorage.getItem('monitorAudio') || '1') === '1';
        try { tapNode.disconnect(); } catch(_) {}
        tapNode.connect(analyser);
        if (monitor) tapNode.connect(audioContext.destination);
        setupLevelMeter();
      }
      node.connect(tapNode);
      if (visualizer && visualizer.connectAudio) {
        visualizer.connectAudio(tapNode);
        pendingTapConnect = false;
      } else {
        pendingTapConnect = true;
      }
    }

    function startRenderer() {
      if (rendering) return;
      if (!visualizer || !ensureAudioContext()) { showToast('Initializing…'); return; }
      rendering = true;
      let lastAudioT = null;
      const loop = () => {
        if (!rendering) return;
        // Drive elapsed from audio clock for tighter sync
        // Ensure context is running
        if (audioContext && audioContext.state === 'suspended') {
          audioContext.resume().catch(() => {});
        }
        const t = getAudioNow();
        let dt = 0;
        if (lastAudioT != null) dt = Math.max(1/240, Math.min(0.2, t - lastAudioT));
        lastAudioT = t;
        visualizer.render({ elapsedTime: dt });
        // After render, adapt glass opacity based on current frame luminance
        updateGlassOpacity();
        rafId = requestAnimationFrame(loop);
      };
      rafId = requestAnimationFrame(loop);
      hideHero();
      setPlayState(true);
    }

    function stopRenderer() {
      rendering = false;
      if (rafId) cancelAnimationFrame(rafId);
      setPlayState(false);
    }

    function setPlayState(isPlaying) {
      const btn = document.getElementById('playBtn');
      if (!btn) return;
      btn.innerHTML = isPlaying ? '<i class="fa-solid fa-pause"></i>' : '<i class="fa-solid fa-play"></i>';
      btn.setAttribute('aria-pressed', isPlaying ? 'true' : 'false');
      btn.title = isPlaying ? 'Pause' : 'Render';
    }

    function playBufferSource(buffer) {
      startRenderer();
      if (sourceNode) {
        sourceNode.disconnect();
      }
      ensureAudioContext();
      if (internalMethod === 'element') {
        try { htmlAudioEl?.pause?.(); } catch(_) {}
        htmlAudioEl = new Audio();
        const blob = new Blob([buffer.getChannelData ? buffer.getChannelData(0).buffer : buffer], { type: 'audio/wav' });
        // Fallback: when we already have decoded buffer, rebuild via OfflineAudioContext for URL is complex.
        // So default to bufferSource path when we only have decoded PCM.
        // Element path will be used when loading file directly (see playFileViaElement).
        sourceNode = audioContext.createBufferSource();
        sourceNode.buffer = buffer;
        connectToAudioTap(sourceNode);
        sourceNode.start(0);
      } else {
        sourceNode = audioContext.createBufferSource();
        sourceNode.buffer = buffer;
        connectToAudioTap(sourceNode);
        sourceNode.start(0);
      }
      announce('Playing local audio');
    }

    function loadLocalFiles(fileList, index = 0) {
      ensureAudioContext();
      audioContext.resume();
      showBusy(true, 'Decoding audio…');
      const reader = new FileReader();
      reader.onload = (event) => {
        if (internalMethod === 'element') {
          try { htmlAudioEl?.pause?.(); } catch(_) {}
          htmlAudioEl = new Audio();
          const blob = new Blob([event.target.result]);
          const url = URL.createObjectURL(blob);
          htmlAudioEl.src = url;
          htmlAudioEl.crossOrigin = 'anonymous';
          htmlAudioEl.autoplay = true;
          htmlAudioEl.onplay = () => {
            try {
              const mediaSrc = audioContext.createMediaElementSource(htmlAudioEl);
              connectToAudioTap(mediaSrc);
              showBusy(false);
              showToast('Now playing (element capture)');
            } catch (e) {
              console.warn('Element capture failed, falling back', e);
            }
          };
          htmlAudioEl.play().catch(() => {});
        } else {
          audioContext.decodeAudioData(
            event.target.result,
            (buf) => {
              playBufferSource(buf);
              setTimeout(() => {
                if (fileList.length > index + 1) {
                  loadLocalFiles(fileList, index + 1);
                } else {
                  if (sourceNode) {
                    sourceNode.disconnect();
                    sourceNode = null;
                  }
                }
              }, buf.duration * 1000);
              showBusy(false);
              showToast('Now playing: local file');
            }
          );
        }
      };
      reader.readAsArrayBuffer(fileList[index]);
    }

    async function connectMic() {
      const useRNNoise = (localStorage.getItem('rnnoise') || '0') === '1';
      const sensitivity = Number(localStorage.getItem('micSensitivity') || '1.4');
      const constraints = { audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: false } };
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        console.error('getUserMedia not supported');
        return;
      }
      try {
        ensureAudioContext();
        audioContext.resume();
        const res = useRNNoise && visualizer.startMicCaptureEnhanced
          ? await visualizer.startMicCaptureEnhanced({ constraints, suppression: 'rnnoise', sensitivity })
          : await visualizer.startMicCapture(constraints);
        micStream = res.stream;
        micSourceNode = audioContext.createMediaStreamSource(micStream);
        micGainNode = audioContext.createGain();
        micGainNode.gain.value = sensitivity;
        micSourceNode.connect(micGainNode);
        connectToAudioTap(micGainNode);
        micConnected = true;
        startRenderer();
        showToast(`Mic connected${useRNNoise ? ' (RNNoise)' : ''}`);
        announce('Microphone connected');
        try { document.getElementById('micBtn').classList.add('mic-on'); } catch(_) {}
      } catch (err) {
        console.error('Error getting audio stream from getUserMedia', err);
        showToast('Mic permission denied', true);
        announce('Microphone permission denied');
        try { document.getElementById('micBtn').classList.remove('mic-on'); } catch(_) {}
      }
    }

    function disconnectMic(stopStream = true) {
      try { micSourceNode && micSourceNode.disconnect(); } catch(_) {}
      try { micGainNode && micGainNode.disconnect(); } catch(_) {}
      if (stopStream && micStream) {
        try { micStream.getTracks().forEach(t => t.stop()); } catch(_) {}
      }
      micSourceNode = null;
      micGainNode = null;
      if (stopStream) micStream = null;
      micConnected = false;
      try { document.getElementById('micBtn').classList.remove('mic-on'); } catch(_) {}
      showToast('Mic off');
      announce('Microphone disconnected');
    }

    function nextPreset(blendTime = 5.7) {
      if (!visualizer) { showToast('Initializing…'); return; }
      presetIndexHist.push(presetIndex);
      const pool = getEnabledKeys();
      if (!pool.length) { showToast('No presets enabled', true); return; }
      if (presetRandom) {
        presetIndex = presetKeys.indexOf(pool[Math.floor(Math.random() * pool.length)]);
      } else {
        let i = presetIndex;
        for (let step = 0; step < presetKeys.length; step++) {
          i = (i + 1) % presetKeys.length;
          if (!isDisabled(presetKeys[i])) { presetIndex = i; break; }
        }
      }
      const key = presetKeys[presetIndex];
      visualizer.loadPreset(presets[key], blendTime);
      try { visualizer.renderer?.applyStyleFromName?.(key); } catch(_) {}
      highlightActivePreset();
      showPresetToast(key);
    }

    function prevPreset(blendTime = 5.7) {
      if (!visualizer) { showToast('Initializing…'); return; }
      const numPresets = presetKeys.length;
      if (presetIndexHist.length > 0) {
        presetIndex = presetIndexHist.pop();
      } else {
        let i = presetIndex;
        for (let step = 0; step < numPresets; step++) {
          i = ((i - 1) + numPresets) % numPresets;
          if (!isDisabled(presetKeys[i])) { presetIndex = i; break; }
        }
      }
      const key = presetKeys[presetIndex];
      visualizer.loadPreset(presets[key], blendTime);
      try { visualizer.renderer?.applyStyleFromName?.(key); } catch(_) {}
      highlightActivePreset();
      showPresetToast(key);
    }

    function restartCycleInterval() {
      if (cycleInterval) {
        clearInterval(cycleInterval);
        cycleInterval = null;
      }
      if (presetCycle) {
        cycleInterval = setInterval(() => nextPreset(2.7), presetCycleLength);
      }
    }

    // Audio mode handling
    function applyAudioMode(mode) {
      // mode: 'mic' | 'internal' | 'both'
      localStorage.setItem('audioMode', mode);
      // Ensure mic initialized if needed
      if ((mode === 'mic' || mode === 'both') && !micSourceNode) {
        connectMic();
      }
      // Mic routing
      if (micGainNode) {
        try { micSourceNode.disconnect(); micSourceNode.connect(micGainNode); } catch(_) {}
        try { micGainNode.disconnect(); } catch(_) {}
        if (mode === 'mic' || mode === 'both') {
          micGainNode.gain.value = (mode === 'mic') ? 1.6 : 1.35; // amplify responsiveness to mic
          micGainNode.connect(tapNode);
          micConnected = true;
        } else {
          // Fully detach mic from graph
          try { micSourceNode.disconnect(); } catch(_) {}
          try { micGainNode.disconnect(); } catch(_) {}
          micConnected = false;
        }
      }
      // Update mic indicator
      try { (micConnected ? document.getElementById('micBtn').classList.add('mic-on') : document.getElementById('micBtn').classList.remove('mic-on')); } catch(_) {}
      // Internal routing (local file buffer source)
      if (sourceNode) {
        try { sourceNode.disconnect(); } catch(_) {}
        if (mode === 'internal' || mode === 'both') {
          sourceNode.connect(tapNode);
          internalConnected = true;
        } else {
          internalConnected = false;
        }
      }
      // Element audio (if used)
      if (htmlAudioEl && (mode === 'internal' || mode === 'both')) {
        try {
          const mediaSrc = audioContext.createMediaElementSource(htmlAudioEl);
          mediaSrc.connect(tapNode);
        } catch(_) {}
      }
      // Tab capture handling
      if (internalMethod === 'tab' && (mode === 'internal' || mode === 'both')) {
        startTabAudioCapture();
      }
      showToast(`Audio mode: ${mode}`);
    }

    async function startTabAudioCapture() {
      try {
        ensureAudioContext();
        audioContext.resume();
        if (tabStream) { try { tabStream.getTracks().forEach(t => t.stop()); } catch(_) {} tabStream = null; }
        const stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: { echoCancellation: false } });
        tabStream = stream;
        const tabSource = audioContext.createMediaStreamSource(stream);
        connectToAudioTap(tabSource);
        internalConnected = true;
        showToast('Tab audio capture started');
      } catch (e) {
        console.error('Tab capture failed', e);
        showToast('Tab capture failed', true);
      }
    }

    function resizeRenderer() {
      const top = document.getElementById('topbar').offsetHeight;
      const bottom = document.getElementById('bottombar').offsetHeight;
      const width = window.innerWidth;
      const height = window.innerHeight - top - bottom;
      canvas.width = width;
      canvas.height = height;
      if (visualizer) {
        visualizer.setRendererSize(width, height);
      }
    }

    function currentBackendPref() {
      const sel = document.getElementById('settingBackend');
      return sel ? sel.value : (localStorage.getItem('backendPref') || 'auto');
    }

    function currentDirectPref() {
      const el = document.getElementById('settingDirect');
      if (el) return !!el.checked;
      const stored = localStorage.getItem('directDraw');
      return stored ? stored === '1' : false;
    }

    function reinitVisualizer() {
      const backendPref = currentBackendPref();
      const direct = currentDirectPref();
      localStorage.setItem('backendPref', backendPref);
      localStorage.setItem('directDraw', direct ? '1' : '0');

      const width = canvas.width;
      const height = canvas.height;

      const backend = backendPref === 'webgpu-exp' ? 'webgpu' : backendPref;

      // Stop current renderer loop
      const wasRendering = rendering;
      stopRenderer();

      try { visualizer?.loseGLContext?.(); } catch(_) {}
      visualizer = veedSync.createVisualizer(audioContext, canvas, {
        width,
        height,
        pixelRatio: window.devicePixelRatio || 1,
        textureRatio: 1,
        backend,
        directCanvas: direct
      });

      // Reconnect audio tap if present
      if (tapNode) {
        try { visualizer.connectAudio(tapNode); } catch(_) {}
      }
      // Reload current preset
      try {
        if (presetKeys.length) visualizer.loadPreset(presets[presetKeys[presetIndex]], 0);
      } catch (e) {
        console.error('Failed to load preset after reinit', e);
        showToast('Failed to apply backend change', true);
      }

      if (wasRendering) startRenderer();
      announce('Graphics backend updated');
    }

    function showBusy(state, label = 'Working…') {
      busy.setAttribute('aria-hidden', state ? 'false' : 'true');
      busy.style.opacity = state ? '1' : '0';
      busy.querySelector('.busy-label').textContent = label;
    }

    function showToast(message, isError = false) {
      toast.textContent = message;
      toast.classList.remove('error');
      if (isError) toast.classList.add('error');
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), 2200);
    }
    function showPresetToast(name) {
      toast.classList.remove('error');
      toast.innerHTML = '';
      const span = document.createElement('span');
      span.textContent = `Now showing: ${name}`;
      const btn = document.createElement('button');
      btn.textContent = 'Disable';
      btn.style.marginLeft = '10px';
      btn.className = 'btn small';
      btn.addEventListener('click', () => { disableCurrentPreset(); });
      toast.appendChild(span);
      toast.appendChild(btn);
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), 2500);
    }
    function saveDisabled() { try { localStorage.setItem('disabledPresets', JSON.stringify(Array.from(disabledSet))); } catch(_) {} }
    function loadDisabled() {
      try { const arr = JSON.parse(localStorage.getItem('disabledPresets') || '[]'); if (Array.isArray(arr)) disabledSet = new Set(arr); } catch(_) { disabledSet = new Set(); }
    }
    function isDisabled(key) { return disabledSet.has(key); }
    function getEnabledKeys() { return presetKeys.filter((k) => !isDisabled(k)); }
    function disablePresetByKey(key) { disabledSet.add(key); saveDisabled(); buildPlaylist(); }
    function enablePresetByKey(key) { disabledSet.delete(key); saveDisabled(); buildPlaylist(); }
    function disableCurrentPreset() { const key = presetKeys[presetIndex]; if (!key) return; disablePresetByKey(key); showToast('Preset disabled'); nextPreset(0.5); }

    function announce(message) {
      live.textContent = '';
      setTimeout(() => live.textContent = message, 10);
    }

    function setupLevelMeter() {
      const draw = () => {
        if (analyser && levelArray) {
          analyser.getByteFrequencyData(levelArray);
          const avg = levelArray.reduce((a, b) => a + b, 0) / levelArray.length;
          const pct = Math.min(100, Math.max(0, (avg / 255) * 100));
          level.style.width = pct + '%';
        }
        requestAnimationFrame(draw);
      };
      requestAnimationFrame(draw);
    }

    function getAudioNow() {
      if (!audioContext) {
        return (performance.now() / 1000) + userSyncOffsetMs / 1000;
      }
      try {
        if (audioContext && typeof audioContext.getOutputTimestamp === 'function') {
          const ts = audioContext.getOutputTimestamp();
          return (ts && ts.contextTime ? ts.contextTime : audioContext.currentTime) + userSyncOffsetMs / 1000;
        }
      } catch (_) {}
      const base = (audioContext.baseLatency || 0) + (audioContext.outputLatency || 0);
      return audioContext.currentTime + base + userSyncOffsetMs / 1000;
    }

    // Dynamic background luminance sampling to adapt glass opacity
    let luminanceProbe = null;
    function initLuminanceProbe() {
      try {
        luminanceProbe = document.createElement('canvas');
        luminanceProbe.width = 64; luminanceProbe.height = 64;
        luminanceProbe.style.display = 'none';
        document.body.appendChild(luminanceProbe);
      } catch(_) {}
    }
    function updateGlassOpacity() {
      if (!visualizer || !luminanceProbe) return;
      try {
        const ctx = luminanceProbe.getContext('2d', { willReadFrequently: false });
        if (!ctx) return;
        ctx.drawImage(canvas, 0, 0, luminanceProbe.width, luminanceProbe.height);
        const data = ctx.getImageData(0, 0, luminanceProbe.width, luminanceProbe.height).data;
        let sum = 0;
        for (let i = 0; i < data.length; i += 4) {
          const r = data[i] / 255, g = data[i+1] / 255, b = data[i+2] / 255;
          // Rec. 709 luma
          sum += 0.2126*r + 0.7152*g + 0.0722*b;
        }
        const avgY = sum / (data.length / 4);
        // Map luminance to extra darkening; threshold around 0.55
        const t = Math.max(0, avgY - 0.55);
        const darkBoost = Math.min(0.35, t * 0.85); // cap extra darkening
        document.documentElement.style.setProperty('--bar-darken', String(darkBoost));
        document.documentElement.style.setProperty('--panel-darken', String(darkBoost * 1.1));
      } catch(_) {}
    }
    function applyVibeKey(key){
      try {
        if (!visualizer || !visualizer.renderer) return;
        if (key === 'water') visualizer.renderer.applySceneWater?.();
        else if (key === 'beach') visualizer.renderer.applySceneBeach?.();
        else if (key === 'party') visualizer.renderer.applySceneParty?.();
        else if (key === 'chill') visualizer.renderer.setPostFX?.({ saturation: -0.08, tint: [0.94,1.02,1.06], tonemap: 0.6 });
        else if (key === 'storm') visualizer.renderer.setPostFX?.({ contrast: 0.16, grain: 0.12, tint: [0.96,0.98,1.04] });
      } catch(_) {}
    }

    function buildPlaylist() {
      const list = document.getElementById('presetList');
      list.innerHTML = '';
      const raw = hideDisabled ? presetKeys.filter((k) => !isDisabled(k)) : presetKeys;
      const q = (document.getElementById('presetSearch')?.value || presetSearchTerm || '').toLowerCase().trim();
      const keysForList = q ? raw.filter((k) => k.toLowerCase().includes(q)) : raw;

      // Update meta
      const metaNow = document.getElementById('presetNow');
      const metaCount = document.getElementById('presetCount');
      if (metaNow) metaNow.textContent = presetKeys[presetIndex] ? presetKeys[presetIndex].substring(0, 80) : '—';
      if (metaCount) metaCount.textContent = `${keysForList.length} of ${raw.length}`;
      keysForList.forEach((key) => {
        const i = presetKeys.indexOf(key);
        const li = document.createElement('li');
        li.textContent = key.substring(0, 80);
        li.dataset.index = i;
        if (isDisabled(key)) li.classList.add('disabled');
        const action = document.createElement('button');
        action.className = 'btn small';
        action.style.marginLeft = '10px';
        action.title = isDisabled(key) ? 'Enable preset' : 'Disable preset';
        action.innerHTML = isDisabled(key) ? '<i class="fa-solid fa-rotate"></i>' : '<i class="fa-solid fa-ban"></i>';
        action.addEventListener('click', (e) => {
          e.stopPropagation();
          if (isDisabled(key)) enablePresetByKey(key); else disablePresetByKey(key);
          showToast(isDisabled(key) ? 'Preset disabled' : 'Preset enabled');
        });
        li.addEventListener('click', () => {
          presetIndex = i;
          visualizer.loadPreset(presets[key], 0.5);
          highlightActivePreset();
          playlistPanel.classList.remove('open');
          showPresetToast(key);
        });
        li.appendChild(action);
        list.appendChild(li);
      });
      highlightActivePreset();
    }

    // Sidebar removed

    function highlightActivePreset() {
      const list = document.getElementById('presetList');
      const items = list.querySelectorAll('li');
      items.forEach((li) => li.classList.remove('active'));
      const active = list.querySelector(`li[data-index="${presetIndex}"]`);
      if (active) active.classList.add('active');
      const metaNow = document.getElementById('presetNow');
      if (metaNow) metaNow.textContent = presetKeys[presetIndex] ? presetKeys[presetIndex].substring(0, 80) : '—';
    }

    async function initPlayer() {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();

      // WebGPU detection & badge (non-blocking)
      (async () => {
        try {
          if (navigator.gpu) {
            const adapter = await navigator.gpu.requestAdapter({ powerPreference: 'high-performance' });
            const device = adapter && await adapter.requestDevice();
            if (device) {
              gpuBadge.textContent = 'WebGPU';
              gpuBadge.classList.add('ok');
              const aw = document.getElementById('aboutWebgpu'); if (aw) aw.textContent = 'available';
              const ag = document.getElementById('aboutGpu'); if (ag) ag.textContent = 'WebGPU';
              return;
            }
          }
        } catch(_) {}
        gpuBadge.textContent = 'WebGL2';
        const ag = document.getElementById('aboutGpu'); if (ag) ag.textContent = 'WebGL2';
      })();
      presets = {};
      loadDisabled();
      if (window.base && window.base.default) Object.assign(presets, window.base.default);
      if (window.extra && window.extra.default) Object.assign(presets, window.extra.default);
      // Optionally add a few classic local presets shipped in repo
      const mergeClassic = async () => {
        if (!includeClassicLocal) return;
        const localList = [
          { name: 'Aderrasi - Mother Of Pearl (classic)', path: '../experiments/wasm-eel/presets/Aderrasi - Mother Of Pearl - mash0000 - how to piss off your eyes.json' },
          { name: 'Aderrasi - Potion of Spirits (classic)', path: '../experiments/wasm-eel/presets/Aderrasi - Potion of Spirits.json' },
          { name: 'Rovastar + Geiss - Hurricane Nightmare (classic)', path: '../experiments/wasm-eel/presets/_Rovastar + Geiss - Hurricane Nightmare (Posterize Mix).json' }
        ];
        for (const item of localList) {
          try {
            const res = await fetch(encodeURI(item.path));
            if (res.ok) {
              const obj = await res.json();
              presets[item.name] = obj;
            }
          } catch (_) {}
        }
      };
      await mergeClassic();
      // Sort presets case-insensitively without relying on lodash
      {
        const entries = Object.entries(presets);
        entries.sort((a, b) => a[0].toLowerCase().localeCompare(b[0].toLowerCase()));
        presets = Object.fromEntries(entries);
        presetKeys = entries.map(([k]) => k);
      }
      presetIndex = Math.floor(Math.random() * presetKeys.length);

      // Apply stored backend prefs
      const backendPref = localStorage.getItem('backendPref') || 'auto';
      const direct = (localStorage.getItem('directDraw') || '0') === '1';
      const backend = backendPref === 'webgpu-exp' ? 'webgpu' : backendPref;

      visualizer = veedSync.createVisualizer(audioContext, canvas, {
        width: 800,
        height: 600,
        pixelRatio: window.devicePixelRatio || 1,
        textureRatio: 1,
        backend,
        directCanvas: direct
      });
      // Compatibility shim: ensure model transition API exists by falling back to particle model loader
      if (!visualizer.loadModelWithTransition && visualizer.loadParticleModelFromURL) {
        visualizer.loadModelWithTransition = async (url, opts = {}) => {
          const sampleEvery = opts.sampleEvery || 4;
          await visualizer.loadParticleModelFromURL(url, { sampleEvery, enabled: true });
        };
      }
      if (pendingTapConnect && tapNode && visualizer?.connectAudio) {
        try { visualizer.connectAudio(tapNode); } catch(_) {}
        pendingTapConnect = false;
      }
      // Apply stored particle settings
      const particlesOn = (localStorage.getItem('particlesOn') || '0') === '1';
      const particlesCount = parseInt(localStorage.getItem('particlesCount') || '600', 10);
      visualizer.setParticlesEnabled?.(particlesOn);
      visualizer.configureParticles?.({ maxCount: particlesCount });
      // Apply stored model FX settings and preload a model if present
      const modelFx = (localStorage.getItem('modelFx') || '0') === '1';
      const modelOnly = (localStorage.getItem('modelOnly') || '0') === '1';
      visualizer.setModelEffectsEnabled?.(modelFx);
      visualizer.setModelOnlyMode?.(modelOnly);
      const preloadModel = localStorage.getItem('modelURL');
      if (preloadModel) {
        try {
          if (visualizer.loadModelWithTransition) {
            await visualizer.loadModelWithTransition(preloadModel, { blendTime: 1.5, sampleEvery: 3 });
          } else if (visualizer.loadParticleModelFromURL) {
            await visualizer.loadParticleModelFromURL(preloadModel, { sampleEvery: 3, enabled: true });
          }
        } catch(_) {}
      }
      try {
        visualizer.loadPreset(presets[presetKeys[presetIndex]], 0);
        showPresetToast(presetKeys[presetIndex]);
      } catch (e) {
        console.error('Failed to load preset', e);
        showToast('Failed to load preset', true);
      }
      restartCycleInterval();
      buildPlaylist();
      resizeRenderer();
      window.addEventListener('resize', resizeRenderer);
      // Auto-start rendering so the user sees visuals immediately
      try { startRenderer(); } catch (_) {}

      // Packs toggles
      const packBase = document.getElementById('packBase');
      const packExtra = document.getElementById('packExtra');
      const classicCb = document.getElementById('settingClassicLocal');
      const applyPacks = () => {
        presets = {};
        if (packBase?.checked && window.base?.default) Object.assign(presets, window.base.default);
        if (packExtra?.checked && window.extra?.default) Object.assign(presets, window.extra.default);
        includeClassicLocal = !!classicCb?.checked;
        try { localStorage.setItem('classicLocal', includeClassicLocal ? '1' : '0'); } catch(_) {}
        const loadAndRebuild = async () => {
          if (includeClassicLocal) {
            const localList = [
              { name: 'Aderrasi - Mother Of Pearl (classic)', path: '../experiments/wasm-eel/presets/Aderrasi - Mother Of Pearl - mash0000 - how to piss off your eyes.json' },
              { name: 'Aderrasi - Potion of Spirits (classic)', path: '../experiments/wasm-eel/presets/Aderrasi - Potion of Spirits.json' },
              { name: 'Rovastar + Geiss - Hurricane Nightmare (classic)', path: '../experiments/wasm-eel/presets/_Rovastar + Geiss - Hurricane Nightmare (Posterize Mix).json' }
            ];
            for (const item of localList) {
              try { const res = await fetch(encodeURI(item.path)); if (res.ok) presets[item.name] = await res.json(); } catch(_) {}
            }
          }
          const entries = Object.entries(presets);
          entries.sort((a, b) => a[0].toLowerCase().localeCompare(b[0].toLowerCase()));
          presets = Object.fromEntries(entries);
          presetKeys = entries.map(([k]) => k);
          presetIndex = Math.min(presetIndex, Math.max(0, presetKeys.length - 1));
          buildPlaylist();
          showToast('Preset packs updated');
        };
        loadAndRebuild();
      };
      packBase?.addEventListener('change', applyPacks);
      packExtra?.addEventListener('change', applyPacks);
      if (classicCb) { classicCb.checked = includeClassicLocal; classicCb.addEventListener('change', applyPacks); }
      // Try to load models index for the Models panel
      try {
        const res = await fetch('../assets/models/index.json', { cache: 'no-cache' });
        if (res.ok) modelsIndex = await res.json();
      } catch (_) {}
    }

    // UI wiring
    window.addEventListener('DOMContentLoaded', () => {
      try {
        const params = new URLSearchParams(window.location.search);
        embedMode = params.has('embed') || params.get('embed') === '1';
        if (embedMode) document.body.classList.add('embed');
      } catch(_) {}
      // Bind DOM refs now that elements exist
      canvas = document.getElementById('canvas');
      hero = document.getElementById('hero');
      settingsPanel = document.getElementById('settingsPanel');
      playlistPanel = document.getElementById('playlistPanel');
      busy = document.getElementById('busy');
      toast = document.getElementById('toast');
      live = document.getElementById('live');
      level = document.getElementById('level');
      gpuBadge = document.getElementById('gpuBadge');
      if (gpuBadge) gpuBadge.textContent = 'Detecting…';
      // Sidebar removed

      // Wire UI first; initialize player after to avoid blocking buttons if init errors
      // Init luminance probe for adaptive glass opacity
      initLuminanceProbe();

      document.getElementById('micBtn').addEventListener('click', () => {
        if (micConnected) disconnectMic(true); else connectMic();
      });
      // Optional toggles stored in localStorage
      try {
        const rn = document.getElementById('settingRNNoise');
        if (rn) rn.addEventListener('change', (e) => localStorage.setItem('rnnoise', e.target.checked ? '1' : '0'));
        const sens = document.getElementById('settingMicSensitivity');
        if (sens) sens.addEventListener('input', (e) => localStorage.setItem('micSensitivity', String(e.target.value)));
      } catch(_) {}
      document.getElementById('uploadBtn').addEventListener('click', () => document.getElementById('fileInput').click());
      document.getElementById('fileInput').addEventListener('change', (e) => {
        if (e.target.files && e.target.files.length) {
          loadLocalFiles(e.target.files);
        }
      });
      document.getElementById('playBtn').addEventListener('click', () => {
        if (rendering) { stopRenderer(); showToast('Paused'); announce('Rendering paused'); }
        else { startRenderer(); showToast('Rendering started'); announce('Rendering started'); }
      });
      // Some buttons are not present; guard optional ones
      const prevBtn = document.getElementById('prevBtn');
      const nextBtn = document.getElementById('nextBtn');
      prevBtn?.addEventListener('click', () => prevPreset());
      nextBtn?.addEventListener('click', () => nextPreset());
      document.getElementById('nextArrowBtn').addEventListener('click', () => nextPreset());
      document.getElementById('backArrowBtn').addEventListener('click', () => prevPreset());

      document.getElementById('fullscreenBtn').addEventListener('click', () => {
        const el = canvas;
        if (!document.fullscreenElement) {
          if (el.requestFullscreen) el.requestFullscreen();
        } else {
          if (document.exitFullscreen) document.exitFullscreen();
        }
      });

      document.getElementById('playlistBtn').addEventListener('click', () => {
        playlistPanel.classList.toggle('open');
        announce(playlistPanel.classList.contains('open') ? 'Opened preset list' : 'Closed preset list');
      });
      // Playlist controls: hide disabled, reset
      const playlistPanelEl = document.getElementById('playlistPanel');
      if (playlistPanelEl) {
        // Header meta row
        const meta = document.createElement('div');
        meta.className = 'panel-meta';
        meta.innerHTML = '<div class="now">Now showing: <code id="presetNow">—</code></div><div class="count">(<span id="presetCount">0</span>)</div>';
        playlistPanelEl.insertBefore(meta, playlistPanelEl.querySelector('ul'));

        // Controls
        const controls = document.createElement('div');
        controls.className = 'panel-controls';
        // Search input
        const search = document.createElement('input');
        search.type = 'text'; search.id = 'presetSearch'; search.placeholder = 'Search presets…'; search.className = 'search';
        search.addEventListener('input', (e) => { presetSearchTerm = String(e.target.value || ''); buildPlaylist(); });
        controls.appendChild(search);

        const group = document.createElement('div'); group.className = 'group';
        const chipToggle = document.createElement('label'); chipToggle.className = 'chip-toggle'; chipToggle.title = 'Hide disabled presets';
        const hideCb = document.createElement('input'); hideCb.type = 'checkbox'; hideCb.checked = hideDisabled; hideCb.style.marginRight = '4px';
        chipToggle.appendChild(hideCb); chipToggle.appendChild(document.createTextNode('Hide disabled'));
        const resetBtn = document.createElement('button'); resetBtn.className = 'btn small secondary'; resetBtn.textContent = 'Reset disabled'; resetBtn.title = 'Enable all presets';
        resetBtn.addEventListener('click', () => { disabledSet = new Set(); saveDisabled(); buildPlaylist(); showToast('Disabled list cleared'); });
        hideCb.addEventListener('change', (e) => { hideDisabled = !!e.target.checked; localStorage.setItem('hideDisabled', hideDisabled ? '1' : '0'); buildPlaylist(); });
        group.appendChild(chipToggle); group.appendChild(resetBtn);
        controls.appendChild(group);

        playlistPanelEl.insertBefore(controls, playlistPanelEl.querySelector('ul'));
      }

      document.getElementById('settingsBtn').addEventListener('click', () => {
        settingsPanel.classList.toggle('open');
        announce(settingsPanel.classList.contains('open') ? 'Opened settings' : 'Closed settings');
      });
      // Progressive disclosure toggle
      const advBtn = document.getElementById('toggleAdvanced');
      if (advBtn) {
        const applyAdv = (on) => {
          if (on) { settingsPanel.classList.add('show-advanced'); advBtn.textContent = 'Hide advanced'; }
          else { settingsPanel.classList.remove('show-advanced'); advBtn.textContent = 'Show advanced'; }
          try { localStorage.setItem('showAdvanced', on ? '1' : '0'); } catch(_) {}
        };
        const storedAdv = (localStorage.getItem('showAdvanced') || '0') === '1';
        applyAdv(storedAdv);
        advBtn.addEventListener('click', () => { applyAdv(!settingsPanel.classList.contains('show-advanced')); });
      }
      // Scene shortcuts
      const bindScene = (id, fn) => { const el = document.getElementById(id); if (el) el.addEventListener('click', fn); };
      bindScene('sceneAnimals', async () => {
        try {
          // Prefer model: an animal head or creature
          const url = '../assets/models/animals/cow.obj';
          if (visualizer?.loadModelWithTransition) {
            await visualizer.loadModelWithTransition(url, { sampleEvery: 3, blendTime: 1.5 });
          }
          visualizer.setModelEffectsEnabled?.(true);
          visualizer.setModelOnlyMode?.(false);
          visualizer.applyVibe?.('nature_doc');
          showToast('Scene: Animals');
        } catch(_) { showToast('Animals scene failed', true); }
      });
      bindScene('sceneWater', () => {
        try {
          // Water vibe: cool colors, increased tonemap and subtle zoom
          visualizer.setModelEffectsEnabled?.(false);
          visualizer.setPostFX?.({ tonemap: 0.9, exposure: 0.05, saturation: -0.05, tint: [0.92,1.05,1.08] });
          showToast('Scene: Water');
        } catch(_) { showToast('Water scene failed', true); }
      });
      bindScene('sceneBeach', () => {
        try {
          visualizer.setModelEffectsEnabled?.(false);
          visualizer.applyVibe?.('sunset_beach');
          showToast('Scene: Beach');
        } catch(_) { showToast('Beach scene failed', true); }
      });
      bindScene('sceneParty', () => {
        try {
          visualizer.setModelEffectsEnabled?.(true);
          visualizer.configureParticles?.({ maxCount: 1200 });
          visualizer.setPostFX?.({ saturation: 0.25, contrast: 0.12, grain: 0.18, tint: [1.02,1.0,1.08] });
          showToast('Scene: Party');
        } catch(_) { showToast('Party scene failed', true); }
      });
      // Cinematic FX toggles
      const fxBloom = document.getElementById('fxBloom');
      const fxBassShake = document.getElementById('fxBassShake');
      const fxZoomBounce = document.getElementById('fxZoomBounce');
      const fxCameraShots = document.getElementById('fxCameraShots');
      const fxQuant = document.getElementById('fxQuantize');
      const fxAutoVibe = document.getElementById('fxAutoVibe');
      const fxVibeBars = document.getElementById('fxVibeBars');
      const fxBloomStrength = document.getElementById('fxBloomStrength');
      const fxShakeFreq = document.getElementById('fxShakeFreq');
      const fxShakeZoom = document.getElementById('fxShakeZoom');
      const fxBounceFreq = document.getElementById('fxBounceFreq');
      const reduceMotionCb = document.getElementById('settingReduceMotion');

      const applyFx = _.throttle(() => {
        if (!visualizer) return;
        // Gates
        if (visualizer.renderer) {
          visualizer.renderer.fxGate = visualizer.renderer.fxGate || { bloom: true, bassShake: true, zoomBounce: true, cameraShots: true };
          if (fxBloom) visualizer.renderer.fxGate.bloom = !!fxBloom.checked;
          if (fxBassShake) visualizer.renderer.fxGate.bassShake = !!fxBassShake.checked;
          if (fxZoomBounce) visualizer.renderer.fxGate.zoomBounce = !!fxZoomBounce.checked;
          if (fxCameraShots) visualizer.renderer.fxGate.cameraShots = !!fxCameraShots.checked;
        }
        // Strengths
        visualizer.renderer?.setPostFX?.({
          bassShake: (fxBassShake?.checked ? Math.max(0, Math.min(0.6, parseFloat(fxBloomStrength?.value || '0.0'))) : 0),
          bassShakeFreq: Math.max(0.1, parseFloat(fxShakeFreq?.value || '2.0')),
          bassShakeZoom: Math.max(0.0, parseFloat(fxShakeZoom?.value || '0.05')),
          zoomBounce: (fxZoomBounce?.checked ? 0.35 : 0.0),
          zoomBounceFreq: Math.max(0.1, parseFloat(fxBounceFreq?.value || '1.5')),
        });
        // Quantize & auto vibes
        const bars = Math.max(1, parseInt(fxVibeBars?.value || '4', 10));
        visualizer.renderer?.setQuantizedTransitions?.(!!fxQuant?.checked, bars);
        visualizer.renderer?.enableAutoVibes?.(!!fxAutoVibe?.checked, bars);

        // Persist
        try {
          localStorage.setItem('fxBloom', fxBloom?.checked ? '1' : '0');
          localStorage.setItem('fxBloomStrength', String(fxBloomStrength?.value || '0.4'));
          localStorage.setItem('fxBassShake', fxBassShake?.checked ? '1' : '0');
          localStorage.setItem('fxShakeFreq', String(fxShakeFreq?.value || '2.5'));
          localStorage.setItem('fxShakeZoom', String(fxShakeZoom?.value || '0.06'));
          localStorage.setItem('fxZoomBounce', fxZoomBounce?.checked ? '1' : '0');
          localStorage.setItem('fxCameraShots', fxCameraShots?.checked ? '1' : '0');
          localStorage.setItem('fxBounceFreq', String(fxBounceFreq?.value || '1.6'));
          localStorage.setItem('fxQuantize', fxQuant?.checked ? '1' : '0');
          localStorage.setItem('fxAutoVibe', fxAutoVibe?.checked ? '1' : '0');
          localStorage.setItem('fxVibeBars', String(fxVibeBars?.value || '4'));
        } catch(_) {}
      }, 100);

      [fxBloom, fxBassShake, fxZoomBounce, fxCameraShots, fxQuant, fxAutoVibe, fxVibeBars, fxBloomStrength, fxShakeFreq, fxShakeZoom, fxBounceFreq]
        .forEach((el) => el && el.addEventListener('change', applyFx));

      // Restore persisted FX values
      try {
        if (fxBloom) fxBloom.checked = (localStorage.getItem('fxBloom') || '1') === '1';
        if (fxBloomStrength) fxBloomStrength.value = String(localStorage.getItem('fxBloomStrength') || '0.4');
        if (fxBassShake) fxBassShake.checked = (localStorage.getItem('fxBassShake') || '1') === '1';
        if (fxShakeFreq) fxShakeFreq.value = String(localStorage.getItem('fxShakeFreq') || '2.5');
        if (fxShakeZoom) fxShakeZoom.value = String(localStorage.getItem('fxShakeZoom') || '0.06');
        if (fxZoomBounce) fxZoomBounce.checked = (localStorage.getItem('fxZoomBounce') || '1') === '1';
        if (fxCameraShots) fxCameraShots.checked = (localStorage.getItem('fxCameraShots') || '1') === '1';
        if (fxBounceFreq) fxBounceFreq.value = String(localStorage.getItem('fxBounceFreq') || '1.6');
        if (fxQuant) fxQuant.checked = (localStorage.getItem('fxQuantize') || '1') === '1';
        if (fxAutoVibe) fxAutoVibe.checked = (localStorage.getItem('fxAutoVibe') || '1') === '1';
        if (fxVibeBars) fxVibeBars.value = String(localStorage.getItem('fxVibeBars') || '4');
      } catch(_) {}

      // Reduce motion handling
      if (reduceMotionCb) {
        const storedRM = (localStorage.getItem('reduceMotion') || '0') === '1';
        reduceMotionCb.checked = storedRM;
        const applyReduceMotion = (enabled) => {
          if (!visualizer?.renderer) return;
          if (enabled) {
            if (fxBassShake) fxBassShake.checked = false;
            if (fxZoomBounce) fxZoomBounce.checked = false;
            visualizer.renderer.setPostFX?.({ bassShake: 0, zoomBounce: 0 });
          }
          try { localStorage.setItem('reduceMotion', enabled ? '1' : '0'); } catch(_) {}
          document.body.setAttribute('data-reduce-motion', enabled ? '1' : '0');
          applyFx();
          showToast(`Reduce motion ${enabled ? 'enabled' : 'disabled'}`);
        };
        reduceMotionCb.addEventListener('change', (e) => applyReduceMotion(!!e.target.checked));
        if (storedRM) applyReduceMotion(true); else applyFx();
      } else {
        applyFx();
      }


      document.getElementById('settingCycle').addEventListener('change', (e) => {
        presetCycle = e.target.checked;
        restartCycleInterval();
        showToast(`Cycle ${presetCycle ? 'enabled' : 'disabled'}`);
      });
      document.getElementById('settingRandom').addEventListener('change', (e) => {
        presetRandom = e.target.checked;
        showToast(`Random ${presetRandom ? 'enabled' : 'disabled'}`);
      });
      document.getElementById('settingCycleLen').addEventListener('change', (e) => {
        const v = parseInt(e.target.value, 10);
        if (!Number.isNaN(v) && v > 0) {
          presetCycleLength = v * 1000;
          restartCycleInterval();
          showToast(`Cycle length set to ${v}s`);
        }
      });

      // Backend controls
      const backendSel = document.getElementById('settingBackend');
      const directCb = document.getElementById('settingDirect');
      const particleCb = document.getElementById('settingParticles');
      const particleNum = document.getElementById('settingParticleCount');
      const monitorCb = document.getElementById('settingMonitor');
      const audioModeSel = document.getElementById('settingAudioMode');
      const internalMethodSel = document.getElementById('settingInternalMethod');
      const grooveSel = document.getElementById('settingGroove');
      const modelFxCb = document.getElementById('settingModelEffects');
      const modelOnlyCb = document.getElementById('settingModelOnly');
      if (backendSel) {
        const stored = localStorage.getItem('backendPref') || 'auto';
        backendSel.value = stored;
        backendSel.addEventListener('change', () => { reinitVisualizer(); });
      }
      if (directCb) {
        const storedD = (localStorage.getItem('directDraw') || '0') === '1';
        directCb.checked = storedD;
        directCb.addEventListener('change', () => { reinitVisualizer(); });
      }
      if (particleCb) {
        const pOn = (localStorage.getItem('particlesOn') || '0') === '1';
        particleCb.checked = pOn;
        particleCb.addEventListener('change', (e) => {
          localStorage.setItem('particlesOn', e.target.checked ? '1' : '0');
          visualizer.setParticlesEnabled?.(e.target.checked);
          showToast(`Particles ${e.target.checked ? 'enabled' : 'disabled'}`);
        });
      }
      if (particleNum) {
        particleNum.value = String(parseInt(localStorage.getItem('particlesCount') || '600', 10));
        particleNum.addEventListener('change', (e) => {
          const val = Math.max(0, Math.min(5000, parseInt(e.target.value || '0', 10)));
          localStorage.setItem('particlesCount', String(val));
          visualizer.configureParticles?.({ maxCount: val });
          showToast(`Particles: ${val}`);
        });
      }
      if (monitorCb) {
        const storedM = (localStorage.getItem('monitorAudio') || '1') === '1';
        monitorCb.checked = storedM;
        monitorCb.addEventListener('change', (e) => {
          localStorage.setItem('monitorAudio', e.target.checked ? '1' : '0');
          // Rehook tap routing
          try {
            if (tapNode) {
              tapNode.disconnect();
              tapNode.connect(analyser);
              if (e.target.checked && audioContext?.destination) tapNode.connect(audioContext.destination);
            }
          } catch (_) {}
          showToast(`Monitor ${e.target.checked ? 'on' : 'off'}`);
        });
      }
      if (audioModeSel) {
        const storedMode = localStorage.getItem('audioMode') || 'internal';
        audioModeSel.value = storedMode;
        audioModeSel.addEventListener('change', (e) => {
          const mode = e.target.value;
          applyAudioMode(mode);
          // Inform renderer about mic amplification bias
          if (visualizer?.renderer?.setMicActive) {
            visualizer.renderer.setMicActive(mode === 'mic' || mode === 'both', mode === 'mic' ? 1.8 : 1.5);
          }
        });
        setTimeout(() => {
          applyAudioMode(storedMode);
          if (visualizer?.renderer?.setMicActive) {
            visualizer.renderer.setMicActive(storedMode === 'mic' || storedMode === 'both', storedMode === 'mic' ? 1.8 : 1.5);
          }
        }, 0);
      }
      if (internalMethodSel) {
        const storedIm = localStorage.getItem('internalMethod') || 'auto';
        internalMethodSel.value = storedIm;
        internalMethodSel.addEventListener('change', (e) => {
          internalMethod = e.target.value;
          localStorage.setItem('internalMethod', internalMethod);
          showToast(`Internal source: ${internalMethod}`);
          if (internalMethod === 'tab' && (audioModeSel?.value === 'internal' || audioModeSel?.value === 'both')) {
            startTabAudioCapture();
          }
        });
      }
      if (modelFxCb) {
        const stored = (localStorage.getItem('modelFx') || '0') === '1';
        modelFxCb.checked = stored;
        if (visualizer?.setModelEffectsEnabled) visualizer.setModelEffectsEnabled(stored);
        modelFxCb.addEventListener('change', (e) => {
          localStorage.setItem('modelFx', e.target.checked ? '1' : '0');
          if (visualizer?.setModelEffectsEnabled) visualizer.setModelEffectsEnabled(e.target.checked);
          showToast(`Model effects ${e.target.checked ? 'enabled' : 'disabled'}`);
        });
      }
      if (modelOnlyCb) {
        const stored = (localStorage.getItem('modelOnly') || '0') === '1';
        modelOnlyCb.checked = stored;
        if (visualizer?.setModelOnlyMode) visualizer.setModelOnlyMode(stored);
        modelOnlyCb.addEventListener('change', (e) => {
          localStorage.setItem('modelOnly', e.target.checked ? '1' : '0');
          if (visualizer?.setModelOnlyMode) visualizer.setModelOnlyMode(e.target.checked);
          showToast(`Mode: ${e.target.checked ? 'Model-only' : 'Mixed'}`);
        });
      }
      if (grooveSel) {
        const storedG = localStorage.getItem('groove') || 'light_swing';
        grooveSel.value = storedG;
        const applyGroove = (g) => {
          try {
            visualizer?.renderer?.setMomentConfig?.({ groove: g });
            showToast(`Groove: ${g.replace('_', ' ')}`);
          } catch(_) {}
        };
        grooveSel.addEventListener('change', (e) => {
          const g = e.target.value;
          localStorage.setItem('groove', g);
          applyGroove(g);
        });
        // apply at init
        setTimeout(() => applyGroove(storedG), 0);
      }

      // Sync offset controls
      const offsetRange = document.getElementById('settingOffsetRange');
      const offsetNum = document.getElementById('settingOffsetNum');
      if (offsetRange && offsetNum) {
        offsetRange.value = String(userSyncOffsetMs);
        offsetNum.value = String(userSyncOffsetMs);
        const apply = (val) => {
          userSyncOffsetMs = Math.max(-200, Math.min(200, parseInt(val || '0', 10)));
          localStorage.setItem('syncOffsetMs', String(userSyncOffsetMs));
          offsetRange.value = String(userSyncOffsetMs);
          offsetNum.value = String(userSyncOffsetMs);
          showToast(`Sync offset ${userSyncOffsetMs} ms`);
          announce(`Sync offset ${userSyncOffsetMs} milliseconds`);
        };
        offsetRange.addEventListener('input', (e) => apply(e.target.value));
        offsetNum.addEventListener('change', (e) => apply(e.target.value));
      }

      // Keyboard shortcuts
      window.addEventListener('keydown', (e) => {
        if (e.target && ['INPUT', 'TEXTAREA'].includes(e.target.tagName)) return;
        if (e.code === 'Space') { if (rendering) stopRenderer(); else startRenderer(); e.preventDefault(); }
        if (e.code === 'ArrowRight') nextPreset();
        if (e.code === 'ArrowLeft') prevPreset();
        if (e.key.toLowerCase() === 'x') disableCurrentPreset();
        if (e.key.toLowerCase() === 'f') document.getElementById('fullscreenBtn').click();
        if (e.key.toLowerCase() === 'p') document.getElementById('playlistBtn').click();
        if (e.key.toLowerCase() === 's') document.getElementById('settingsBtn').click();
        if (e.key === 'Escape') {
          try { document.getElementById('settingsPanel').classList.remove('open'); } catch(_) {}
          try { document.getElementById('playlistPanel').classList.remove('open'); } catch(_) {}
          try { closeModal('packsModal'); } catch(_) {}
          try { closeModal('aboutModal'); } catch(_) {}
          try { closeModal('modelsModal'); } catch(_) {}
        }
      });

      // Drag & drop upload
      window.addEventListener('dragover', (e) => { e.preventDefault(); });
      window.addEventListener('drop', (e) => {
        e.preventDefault();
        const files = Array.from(e.dataTransfer?.files || []).filter(f => /^audio\//.test(f.type));
        if (files.length) { loadLocalFiles(files); showToast(`Loaded ${files.length} file(s)`); }
      });

      // Top bar actions
      document.getElementById('extensionsBtn').addEventListener('click', () => openModal('packsModal'));
      document.getElementById('aboutBtn').addEventListener('click', () => openModal('aboutModal'));
      const modelsBtn = document.getElementById('modelsBtn');
      if (modelsBtn) {
        modelsBtn.addEventListener('click', () => {
          if (!modelsIndex) {
            fetch('../assets/models/index.json', { cache: 'no-cache' })
              .then(r => r.ok ? r.json() : null)
              .then(j => { modelsIndex = j; renderModelsPanel(); openModal('modelsModal'); })
              .catch(() => { showToast('No models index found', true); });
          } else {
            renderModelsPanel();
            openModal('modelsModal');
          }
        });
      }
      // Kick off initialization last and handle failures gracefully
      (async () => {
        try {
          await initPlayer();
        } catch (e) {
          console.error('Visualizer init failed', e);
          showToast('Initialization failed', true);
          announce('Initialization failed');
        }
      })();
    });
    
    // Message bridge for iframe embedding
    window.addEventListener('message', async (event) => {
      const payload = event && event.data ? event.data : null;
      const reply = (msg) => { try { event.source && event.source.postMessage(msg, '*'); } catch(_) {} };
      if (!payload || !payload.type) return;
      switch (payload.type) {
        case 'viz:getSnapshot': {
          let url = '';
          try { url = (document.getElementById('canvas')?.toDataURL && document.getElementById('canvas').toDataURL('image/png')) || ''; } catch(_) {}
          reply({ type: 'viz:snapshot', dataUrl: url });
          break;
        }
        case 'viz:toggleMic': {
          try { if (micConnected) disconnectMic(true); else await connectMic(); } catch(_) {}
          reply({ type: 'viz:mic', on: !!micConnected });
          break;
        }
        case 'viz:applyVibe': {
          try { applyVibeKey(payload.key); } catch(_) {}
          break;
        }
        case 'viz:setEmbed': {
          try {
            const on = payload.value !== false ? true : false;
            if (on) document.body.classList.add('embed'); else document.body.classList.remove('embed');
          } catch(_) {}
          break;
        }
        default: break;
      }
    });
  </script>

  <style>
    :root {
      --bar-bg: #0f1115; /* darker, angular Cybertruck vibe */
      --bar-fg: #e5ecf5;
      --bar-fg-dim: #b7c2d4;
      --accent: #c0ff33; /* cyber green accent */
      --accent-cyan: #5dd6ff;
      --accent-magenta: #ff64c3;
      --font-display: "Barrio", system-ui;
      --font-body: "Inter", -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      --font-mono: "Fira Code", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      --glass-blur: 22px;
      --glass-bg1: rgba(255,255,255,0.16);
      --glass-bg2: rgba(255,255,255,0.08);
      --glass-stroke: rgba(255,255,255,0.22);
      --glass-glow: rgba(192,255,51,0.28);
      --water-blur: 28px;
      --water-tint1: rgba(180, 220, 255, 0.10);
      --water-tint2: rgba(120, 180, 255, 0.06);
      --bar-darken: 0;
      --panel-darken: 0;
    }

    html, body {
      height: 100%;
      margin: 0;
      background: #0a0b1e;
      color: var(--bar-fg);
      font-family: var(--font-body);
    }

    .barrio-regular { font-family: "Barrio", system-ui; font-weight: 400; font-style: normal; }

    /* Liquid glass bars */
    #topbar, #bottombar {
      position: fixed;
      left: 0;
      right: 0;
      background:
        linear-gradient(135deg, rgba(0,0,0, var(--bar-darken)), rgba(0,0,0, var(--bar-darken))),
        linear-gradient(135deg, var(--water-tint1), var(--water-tint2));
      backdrop-filter: blur(var(--water-blur)) saturate(180%);
      -webkit-backdrop-filter: blur(var(--water-blur)) saturate(180%);
      color: var(--bar-fg);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 16px;
      z-index: 5;
      box-shadow: 0 1px 0 rgba(255,255,255,0.04) inset, 0 -1px 0 rgba(255,255,255,0.04) inset, 0 8px 24px rgba(0,0,0,0.18);
      border: 1px solid rgba(255,255,255,0.08);
      isolation: isolate; /* ensure blend happens against bar background, not canvas */
    }
    #topbar, #bottombar { position: fixed; overflow: hidden; }
    #topbar::before, #bottombar::before,
    #settingsPanel::before, #playlistPanel::before,
    .modal-card::before, #toast::before, .busy-card::before {
      content: ""; position: absolute; inset: 0; pointer-events: none;
      background:
        radial-gradient(120% 60% at 10% -20%, rgba(255,255,255,0.28), rgba(255,255,255,0) 60%),
        radial-gradient(80% 50% at 120% 0%, rgba(255,255,255,0.16), rgba(255,255,255,0) 70%);
      mix-blend-mode: screen; opacity: 0.9;
    }
    #topbar::after, #bottombar::after,
    #settingsPanel::after, #playlistPanel::after,
    .modal-card::after, #toast::after, .busy-card::after {
      content: ""; position: absolute; inset: -20% -10%; pointer-events: none;
      background: conic-gradient(from 0deg at 50% 50%, rgba(255,255,255,0.08) 0 10%, rgba(255,255,255,0) 10% 100%);
      filter: blur(14px); opacity: 0.4; animation: caustics 18s linear infinite;
      mask-image: radial-gradient(120% 100% at 50% 50%, #000 40%, transparent 80%);
    }
    @keyframes caustics { to { transform: rotate(360deg) translate3d(0,0,0); } }

    #topbar { top: 0; height: 56px; }
    #bottombar { bottom: 0; height: 70px; }

    .brand {
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 700;
      font-size: 26px;
      font-family: var(--font-display);
      letter-spacing: .3px;
    }

    .brand .logo {
      width: 36px;
      height: 36px;
      border: 3px solid var(--accent);
      border-radius: 4px; /* angular */
      display: grid;
      place-items: center;
      color: var(--accent);
      font-size: 18px;
    }

    .top-actions i {
      font-size: 20px; margin-left: 18px; opacity: 0.9; cursor: pointer;
      transition: transform .12s ease, opacity .12s ease;
      color: #fff;
      display: inline-grid; place-items: center; padding: 4px; border-radius: 8px;
      /* Create local contrast bubble by inverting only the backdrop under the icon */
      backdrop-filter: invert(1) saturate(120%);
      -webkit-backdrop-filter: invert(1) saturate(120%);
      mix-blend-mode: normal;
    }
    .top-actions i:hover { opacity: 1; transform: translateY(-1px); }
    .gpu-badge { margin-left: 12px; padding: 4px 8px; border-radius: 8px; background: rgba(255,255,255,0.08); font-size: 12px; letter-spacing: .3px; font-family: var(--font-mono); }
    .gpu-badge.ok { background: rgba(80,200,120,0.22); }

    .bar-section {
      display: flex;
      align-items: center;
      gap: 18px;
    }

    .btn {
      width: 44px; height: 44px;
      border-radius: 12px;
      background: linear-gradient(135deg, rgba(255,255,255,0.08), rgba(255,255,255,0.04));
      color: var(--bar-fg);
      border: 1px solid var(--glass-stroke);
      display: grid; place-items: center; cursor: pointer;
      box-shadow: 0 8px 24px rgba(0,0,0,0.25), inset 0 1px 0 rgba(255,255,255,0.18);
      backdrop-filter: blur(calc(var(--glass-blur) * 0.5)) saturate(140%);
      -webkit-backdrop-filter: blur(calc(var(--glass-blur) * 0.5)) saturate(140%);
      transition: transform .12s ease, box-shadow .12s ease, background .12s ease;
    }
    .btn:hover { transform: translateY(-1px) scale(1.02); box-shadow: 0 10px 28px rgba(0,0,0,0.28), 0 0 0 2px rgba(255,255,255,0.06) inset; }
    .btn:active { transform: translateY(1px) scale(0.99); }
    .btn i {
      font-size: 18px; color: #fff;
      display: inline-grid; place-items: center; padding: 4px; border-radius: 8px;
      backdrop-filter: invert(1) saturate(120%);
      -webkit-backdrop-filter: invert(1) saturate(120%);
      mix-blend-mode: normal;
    }
    /* Mic active state: greenish glow + inverted icon */
    .btn.mic-on {
      border-color: var(--accent);
      background:
        radial-gradient(120% 100% at 50% 0%, rgba(192,255,51,0.14), rgba(192,255,51,0.06)),
        linear-gradient(135deg, rgba(255,255,255,0.10), rgba(255,255,255,0.05));
      box-shadow:
        0 0 0 2px rgba(192,255,51,0.28),
        0 0 22px rgba(192,255,51,0.22),
        0 10px 26px rgba(0,0,0,0.24),
        inset 0 1px 0 rgba(255,255,255,0.22);
    }
    .btn.mic-on i { filter: invert(1) hue-rotate(120deg) saturate(1.2); }
    .btn:focus-visible { outline: 2px solid #5b8cff; outline-offset: 2px; }

    #canvas {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      width: 100vw;
      height: 100vh;
      background: #000;
      display: block;
    }
    /* Embed mode hides chrome */
    body.embed #topbar,
    body.embed #bottombar,
    body.embed #settingsPanel,
    body.embed #playlistPanel,
    body.embed #hero { display: none !important; }

    #hero {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: grid;
      place-items: center;
      background: url('../preview.png') center/cover no-repeat;
      z-index: 3;
      text-align: center;
    }
    #hero.hidden { opacity: 0; pointer-events: none; transition: opacity .4s ease; }

    .hero-inner {
      transform: translateY(-8%);
      color: #ffeaa8;
      text-shadow: 0 2px 8px rgba(0,0,0,0.6);
    }
    .hero-title {
      font-size: 86px;
      margin: 18px 0 8px;
      font-weight: 800;
      font-family: var(--font-display);
    }
    .hero-subtitle {
      font-size: 40px;
      opacity: 0.95;
    }

    /* Panels */
    /* Liquid glass panels */
    #settingsPanel, #playlistPanel {
      position: fixed;
      bottom: 80px;
      right: 16px;
      background:
        linear-gradient(135deg, rgba(0,0,0, var(--panel-darken)), rgba(0,0,0, var(--panel-darken))),
        linear-gradient(135deg, rgba(255,255,255,0.14), rgba(255,255,255,0.06));
      backdrop-filter: blur(calc(var(--water-blur) * 0.9)) saturate(220%);
      -webkit-backdrop-filter: blur(calc(var(--water-blur) * 0.9)) saturate(220%);
      border: 1px solid rgba(255,255,255,0.16);
      border-radius: 12px;
      padding: 16px;
      width: clamp(280px, 38vw, 420px);
      max-height: 50vh;
      overflow: auto;
      transform: translateY(20px);
      opacity: 0;
      pointer-events: none;
      transition: all .2s ease;
      z-index: 10;
      color: var(--bar-fg);
      box-shadow: 0 16px 40px rgba(0,0,0,0.38), inset 0 1px 0 rgba(255,255,255,0.18);
    }
    .scene-grid { display:grid; grid-template-columns: repeat(4, minmax(0,1fr)); gap: 10px; margin: 10px 0 6px; }
    .scene-btn { display:flex; align-items:center; justify-content:center; gap:8px; padding:10px 12px; border-radius:12px; cursor:pointer; border: 1px solid var(--glass-stroke); background: linear-gradient(135deg, var(--glass-bg1), var(--glass-bg2)); box-shadow: 0 6px 18px rgba(0,0,0,0.18), inset 0 1px 0 rgba(255,255,255,0.16); color: var(--bar-fg); }
    .scene-btn:hover { box-shadow: 0 10px 26px rgba(0,0,0,0.24), inset 0 1px 0 rgba(255,255,255,0.20); transform: translateY(-1px); }
    .scene-btn i { font-size:16px; }
    #playlistPanel { right: 360px; width: clamp(320px, 48vw, 540px); }
    #settingsPanel.open, #playlistPanel.open { transform: translateY(0); opacity: 1; pointer-events: auto; }
    #settingsPanel h4, #playlistPanel h4 { margin: 0 0 10px; font-size: 16px; font-weight: 700; }

    .setting-row { display: grid; grid-template-columns: 28px 1fr auto; align-items: center; gap: 12px; margin: 10px 0; padding: 10px 12px; border-radius: 14px; background: linear-gradient(135deg, var(--glass-bg1), var(--glass-bg2)); border: 1px solid var(--glass-stroke); box-shadow: 0 10px 26px rgba(0,0,0,0.22), inset 0 1px 0 rgba(255,255,255,0.18); }
    .setting-row .icon { width: 28px; height: 28px; display: grid; place-items: center; border-radius: 8px; background: linear-gradient(135deg, rgba(255,255,255,0.18), rgba(255,255,255,0.06)); border: 1px solid var(--glass-stroke); color: var(--bar-fg); }
    .setting-row label { display: block; font-weight: 600; }
    .setting-row small { display: block; opacity: .75; font-size: 12px; font-weight: 400; }

    /* Liquid glass controls */
    #settingsPanel input[type="checkbox"] {
      appearance: none;
      -webkit-appearance: none;
      width: 46px; height: 26px; border-radius: 999px;
      background: linear-gradient(135deg, rgba(255,255,255,0.22), rgba(255,255,255,0.10));
      border: 1px solid var(--glass-stroke);
      position: relative; cursor: pointer;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.18), 0 6px 18px rgba(0,0,0,0.22);
      transition: background .15s ease, border-color .15s ease;
    }
    #settingsPanel input[type="checkbox"]::after {
      content: ""; position: absolute; top: 2px; left: 2px;
      width: 22px; height: 22px; border-radius: 50%;
      background: #fff; box-shadow: 0 2px 6px rgba(0,0,0,0.25);
      transition: transform .18s ease, background .15s ease;
    }
    #settingsPanel input[type="checkbox"]:checked {
      background: linear-gradient(135deg, rgba(192,255,51,0.65), rgba(192,255,51,0.35));
      border-color: rgba(192,255,51,0.7);
    }
    #settingsPanel input[type="checkbox"]:checked::after { transform: translateX(20px); background: #0a0b1e; }
    #settingsPanel input[type="checkbox"]:focus-visible { outline: 2px solid #5b8cff; outline-offset: 2px; }

    #settingsPanel select,
    #settingsPanel input[type="number"],
    #settingsPanel input[type="text"] {
      -webkit-appearance: none; appearance: none;
      background: linear-gradient(135deg, rgba(255,255,255,0.18), rgba(255,255,255,0.08));
      color: var(--bar-fg);
      border: 1px solid var(--glass-stroke);
      border-radius: 12px; min-height: 36px;
      padding: 8px 12px; box-shadow: inset 0 1px 0 rgba(255,255,255,0.18), 0 6px 18px rgba(0,0,0,0.18);
    }
    #settingsPanel select { cursor: pointer; padding-right: 34px;
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="%23e5ecf5"><path d="M7 10l5 5 5-5z"/></svg>');
      background-repeat: no-repeat; background-position: right 10px center; background-size: 12px; }
    #settingsPanel select:focus-visible,
    #settingsPanel input[type="number"]:focus-visible,
    #settingsPanel input[type="text"]:focus-visible { outline: 2px solid #5b8cff; outline-offset: 2px; }
    #settingsPanel input[type="number"]::-webkit-outer-spin-button,
    #settingsPanel input[type="number"]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    #settingsPanel input[type="number"] { appearance: textfield; -moz-appearance: textfield; width: 90px; }

    /* Range slider */
    #settingsPanel input[type="range"] { appearance: none; -webkit-appearance: none; width: 100%; height: 6px; border-radius: 999px; border: 1px solid var(--glass-stroke); background: linear-gradient(90deg, rgba(255,255,255,0.18), rgba(255,255,255,0.06)); box-shadow: inset 0 1px 0 rgba(255,255,255,0.18), 0 6px 18px rgba(0,0,0,0.18); }
    #settingsPanel input[type="range"]:focus-visible { outline: 2px solid #5b8cff; outline-offset: 2px; }
    #settingsPanel input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 18px; height: 18px; border-radius: 50%; background: var(--accent); border: 2px solid rgba(255,255,255,0.6); box-shadow: 0 2px 6px rgba(0,0,0,0.25); cursor: pointer; margin-top: -7px; }
    #settingsPanel input[type="range"]::-moz-range-thumb { width: 18px; height: 18px; border-radius: 50%; background: var(--accent); border: 2px solid rgba(255,255,255,0.6); box-shadow: 0 2px 6px rgba(0,0,0,0.25); cursor: pointer; }
    #settingsPanel input[type="range"]::-moz-range-track { height: 6px; border-radius: 999px; background: linear-gradient(90deg, rgba(255,255,255,0.18), rgba(255,255,255,0.06)); border: 1px solid var(--glass-stroke); }
    .setting-row input[type="number"] { width: 70px; }
    .setting-row:hover { box-shadow: 0 10px 28px rgba(0,0,0,0.24), inset 0 1px 0 rgba(255,255,255,0.20); }

    #presetList { list-style: none; padding: 0; margin: 0; }
    #presetList li { padding: 8px 10px; border-radius: 8px; cursor: pointer; }
    #presetList li:hover { background: rgba(255,255,255,0.06); }
    #presetList li.active { background: rgba(255,255,255,0.12); }

    /* Playlist panel premium UI */
    #playlistPanel .panel-meta { display: flex; align-items: center; justify-content: space-between; gap: 8px; margin: 6px 0 10px; }
    #playlistPanel .panel-meta .now { font-weight: 700; opacity: .96; }
    #playlistPanel .panel-meta .now code { font-family: var(--font-mono); font-weight: 600; padding: 2px 6px; border-radius: 8px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.12); }
    #playlistPanel .panel-meta .count { font-size: 12px; opacity: .8; }
    #playlistPanel .panel-controls { display: flex; align-items: center; justify-content: space-between; gap: 10px; margin: 8px 0; flex-wrap: wrap; }
    #playlistPanel .panel-controls .group { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
    #playlistPanel input[type="text"].search { width: 100%; min-height: 36px; border-radius: 10px; padding: 8px 12px; color: var(--bar-fg); background: linear-gradient(135deg, rgba(255,255,255,0.14), rgba(255,255,255,0.06)); border: 1px solid rgba(255,255,255,0.16); box-shadow: inset 0 1px 0 rgba(255,255,255,0.18), 0 6px 18px rgba(0,0,0,0.18); }
    #playlistPanel input[type="text"].search:focus-visible { outline: 2px solid #5b8cff; outline-offset: 2px; }
    #playlistPanel .chip-toggle { display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; border-radius: 999px; background: linear-gradient(135deg, rgba(255,255,255,0.10), rgba(255,255,255,0.04)); border: 1px solid rgba(255,255,255,0.14); font-size: 12px; }
    #playlistPanel .btn.small { width: auto; height: 32px; padding: 0 12px; font-size: 12px; }
    #playlistPanel .btn.secondary { background: linear-gradient(135deg, rgba(255,255,255,0.08), rgba(255,255,255,0.04)); border-color: rgba(255,255,255,0.14); }
    @media (max-width: 640px) {
      #playlistPanel .panel-meta { flex-direction: column; align-items: flex-start; gap: 4px; }
      #playlistPanel .panel-controls { gap: 8px; }
      #playlistPanel .panel-controls .group { width: 100%; justify-content: space-between; }
    }

    /* Busy overlay */
    #busy {
      position: fixed; inset: 56px 0 70px 0; display: grid; place-items: center; background: rgba(8,9,24,0.35); color: var(--bar-fg); z-index: 9; opacity: 0; transition: opacity .2s ease; pointer-events: none;
    }
    .busy-card { background: linear-gradient(135deg, var(--water-tint1), var(--water-tint2)); backdrop-filter: blur(calc(var(--water-blur) * 0.6)); -webkit-backdrop-filter: blur(calc(var(--water-blur) * 0.6)); border: 1px solid rgba(255,255,255,0.12); border-radius: 16px; padding: 14px 16px; display: flex; align-items: center; gap: 10px; box-shadow: 0 18px 48px rgba(0,0,0,0.45); }
    .spinner { width: 18px; height: 18px; border: 3px solid rgba(255,255,255,0.25); border-top-color: var(--accent); border-radius: 50%; animation: spin 1s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Toast */
    #toast { position: fixed; left: 50%; bottom: 80px; transform: translateX(-50%); background: linear-gradient(135deg, var(--water-tint1), var(--water-tint2)); backdrop-filter: blur(calc(var(--water-blur) * 0.4)); -webkit-backdrop-filter: blur(calc(var(--water-blur) * 0.4)); color: var(--bar-fg); padding: 10px 14px; border-radius: 12px; opacity: 0; transition: opacity .15s ease, transform .15s ease; pointer-events: none; z-index: 11; border: 1px solid rgba(255,255,255,0.10); box-shadow: 0 16px 40px rgba(0,0,0,0.38); }

    /* Reduce motion -> disable shimmer */
    body[data-reduce-motion="1"] #topbar::after,
    body[data-reduce-motion="1"] #bottombar::after,
    body[data-reduce-motion="1"] #settingsPanel::after,
    body[data-reduce-motion="1"] #playlistPanel::after,
    body[data-reduce-motion="1"] .modal-card::after,
    body[data-reduce-motion="1"] #toast::after,
    body[data-reduce-motion="1"] .busy-card::after { display: none; }
    #toast.show { opacity: 1; transform: translateX(-50%) translateY(-4px); }
    #toast.error { background: rgba(160,30,30,0.95); }

    /* Level meter */
    .level-wrap { width: 120px; height: 6px; background: rgba(255,255,255,0.08); border-radius: 999px; overflow: hidden; }
    .level { height: 100%; width: 0%; background: linear-gradient(90deg, #5bff8a, #ffd76a); }

    /* Modal */
    .modal { position: fixed; inset: 0; display: grid; place-items: center; background: rgba(4,6,18,0.55); opacity: 0; pointer-events: none; transition: opacity .15s; z-index: 12; }
    .modal.open { opacity: 1; pointer-events: auto; }
    .modal-card { width: min(92vw, 520px); background:
      linear-gradient(135deg, rgba(0,0,0, var(--panel-darken)), rgba(0,0,0, var(--panel-darken))),
      linear-gradient(135deg, rgba(255,255,255,0.14), rgba(255,255,255,0.06)); backdrop-filter: blur(calc(var(--glass-blur) * 0.9)) saturate(220%); -webkit-backdrop-filter: blur(calc(var(--glass-blur) * 0.9)) saturate(220%); border: 1px solid rgba(255,255,255,0.16); border-radius: 16px; padding: 16px; color: var(--bar-fg); box-shadow: 0 22px 48px rgba(0,0,0,0.45), inset 0 1px 0 rgba(255,255,255,0.2); }
    .modal-card h3 { margin: 6px 0 12px; font-size: 18px; }
    .modal-actions { display:flex; justify-content:flex-end; gap: 8px; margin-top: 14px; }
    .chip { display:inline-block; padding: 6px 10px; border-radius: 999px; background: rgba(255,255,255,0.08); margin-right: 8px; font-size: 12px; }
    .row { display:flex; align-items:center; justify-content:space-between; gap: 12px; margin: 10px 0; }
    .row label { font-size: 14px; }
    .models-grid { display:grid; grid-template-columns: 1fr; gap: 8px; max-height: 40vh; overflow:auto; }
    .model-item { padding: 8px 10px; border:1px solid rgba(255,255,255,0.08); border-radius:8px; cursor:pointer; }
    .model-item:hover { background: rgba(255,255,255,0.06); }

    /* Responsive adjustments */
    @media (max-width: 840px) {
      .btn { width: 40px; height: 40px; }
      .bar-section { gap: 12px; }
      #playlistPanel { right: 16px; }
    }
    @media (max-width: 640px) {
      #settingsPanel, #playlistPanel {
        left: 16px;
        right: 16px;
        width: auto;
        max-height: 55vh;
      }
      .setting-row { gap: 10px; }
      .setting-row label { font-size: 13px; }
      .hero-title { font-size: 54px; }
      .hero-subtitle { font-size: 24px; }
      .gpu-badge { display: none; }
    }
  </style>
  <style>
    /* Sidebar removed */
  </style>
  <style>
    /* Progressive disclosure for advanced rows */
    #settingsPanel .advanced { display: none; }
    #settingsPanel.show-advanced .advanced { display: flex; }
    .advanced-toggle { margin: 8px 0 12px; display: inline-block; font-size: 12px; opacity: .8; cursor: pointer; }
  </style>
</head>
<body>
  <div id="topbar">
    <div class="brand">
      <div class="logo"><i class="fa-solid fa-compact-disc"></i></div>
      <div>Veed Sync</div>
    </div>
    <div class="top-actions">
      <i id="extensionsBtn" class="fa-solid fa-puzzle-piece" title="Preset packs"></i>
      <i id="aboutBtn" class="fa-regular fa-circle-question" title="About"></i>
      <i id="modelsBtn" class="fa-solid fa-cubes" title="Models"></i>
      <span id="gpuBadge" class="gpu-badge" title="Graphics backend">Detecting…</span>
    </div>
  </div>

  <div id="hero">
    <div class="hero-inner">
      <div class="logo" style="margin: 0 auto; width: 110px; height: 110px; border-width: 6px; font-size: 40px;"><i class="fa-solid fa-compact-disc"></i></div>
      <div class="hero-title">Veed Sync</div>
      <div class="hero-subtitle">music visualizer</div>
    </div>
  </div>

  <canvas id="canvas"></canvas>

  <div id="bottombar">
    <div class="bar-section">
      <button id="micBtn" class="btn" title="Use Mic"><i class="fa-solid fa-microphone"></i></button>
      <button id="uploadBtn" class="btn" title="Load local files"><i class="fa-solid fa-cloud-arrow-up"></i></button>
      <div class="level-wrap" aria-hidden="true"><div id="level" class="level"></div></div>
    </div>
    <div class="bar-section">
      <button id="playlistBtn" class="btn" title="Presets"><i class="fa-solid fa-list"></i></button>
      <button id="playBtn" class="btn" title="Render"><i class="fa-solid fa-play"></i></button>
      <button id="nextBtn" class="btn" title="Next Preset"><i class="fa-solid fa-forward-step"></i></button>
    </div>
    <div class="bar-section">
      <button id="settingsBtn" class="btn" title="Settings"><i class="fa-solid fa-gear"></i></button>
      <button id="backArrowBtn" class="btn" title="Previous"><i class="fa-solid fa-arrow-left"></i></button>
      <button id="nextArrowBtn" class="btn" title="Next"><i class="fa-solid fa-arrow-right"></i></button>
      <button id="fullscreenBtn" class="btn" title="Fullscreen"><i class="fa-regular fa-square"></i></button>
    </div>
  </div>

  <!-- Sidebar removed -->

  <input id="fileInput" type="file" accept="audio/*" multiple style="display:none" />

  <div id="settingsPanel">
    <h4>Settings</h4>
    <div><button id="toggleAdvanced" class="btn small secondary advanced-toggle">Show advanced</button></div>

    <h4 style="margin-top:10px">Scenes</h4>
    <div class="scene-grid">
      <button class="scene-btn" id="sceneAnimals" title="Animals"><i class="fa-solid fa-paw"></i><span>Animals</span></button>
      <button class="scene-btn" id="sceneWater" title="Water"><i class="fa-solid fa-water"></i><span>Water</span></button>
      <button class="scene-btn" id="sceneBeach" title="Beach"><i class="fa-solid fa-umbrella-beach"></i><span>Beach</span></button>
      <button class="scene-btn" id="sceneParty" title="Party"><i class="fa-solid fa-champagne-glasses"></i><span>Party</span></button>
    </div>

    <h4 style="margin-top:16px">Visuals</h4>
    <div class="setting-row"><div class="icon"><i class="fa-solid fa-burst"></i></div><div><label>Bass Bloom</label><small>Glowing amplification on kick transients</small></div><input id="fxBloom" type="checkbox" checked /></div>
    <div class="setting-row advanced"><div class="icon"><i class="fa-solid fa-sun"></i></div><div><label>Bloom strength</label><small>Intensity of glow</small></div><input id="fxBloomStrength" type="number" min="0" max="1" step="0.05" value="0.4" /></div>

    <h4 style="margin-top:16px">Motion</h4>
    <div class="setting-row"><div class="icon"><i class="fa-solid fa-video"></i></div><div><label>Cinematic shots</label><small>Occasional auto camera moves</small></div><input id="fxCameraShots" type="checkbox" checked /></div>
    <div class="setting-row"><div class="icon"><i class="fa-solid fa-wave-square"></i></div><div><label>Bass Shake</label><small>Subtle camera jiggle on bass</small></div><input id="fxBassShake" type="checkbox" checked /></div>
    <div class="setting-row advanced"><div class="icon"><i class="fa-solid fa-signal"></i></div><div><label>Shake freq (Hz)</label><small>How often the shake occurs</small></div><input id="fxShakeFreq" type="number" min="0.1" max="8" step="0.1" value="2.5" /></div>
    <div class="setting-row advanced"><div class="icon"><i class="fa-solid fa-magnifying-glass"></i></div><div><label>Shake zoom</label><small>Zoom amount during shake</small></div><input id="fxShakeZoom" type="number" min="0" max="0.2" step="0.005" value="0.06" /></div>
    <div class="setting-row"><div class="icon"><i class="fa-solid fa-arrows-to-circle"></i></div><div><label>Downbeat Bounce</label><small>Camera spring on downbeat</small></div><input id="fxZoomBounce" type="checkbox" checked /></div>
    <div class="setting-row advanced"><div class="icon"><i class="fa-solid fa-chart-line"></i></div><div><label>Bounce freq (Hz)</label><small>Spring oscillation frequency</small></div><input id="fxBounceFreq" type="number" min="0.1" max="3" step="0.1" value="1.6" /></div>

    <h4 style="margin-top:16px">Playback</h4>
    <div class="setting-row"><div class="icon"><i class="fa-solid fa-music"></i></div><div><label>Quantize transitions</label><small>Change on bar boundaries</small></div><input id="fxQuantize" type="checkbox" checked /></div>
    <div class="setting-row"><div class="icon"><i class="fa-solid fa-bars"></i></div><div><label>Bars per change</label><small>Number of bars between changes</small></div><input id="fxVibeBars" type="number" min="1" max="8" step="1" value="4" /></div>
    <div class="row"><label for="settingGroove">Groove</label>
      <select id="settingGroove">
        <option value="straight">Straight</option>
        <option value="light_swing" selected>Light Swing</option>
        <option value="heavy_swing">Heavy Swing</option>
      </select>
    </div>
    <div class="setting-row"><div class="icon"><i class="fa-solid fa-shuffle"></i></div><div><label for="settingCycle">Cycle presets</label><small>Auto-advance through styles</small></div><input id="settingCycle" type="checkbox" checked /></div>
    <div class="setting-row advanced"><div class="icon"><i class="fa-solid fa-timer"></i></div><div><label for="settingCycleLen">Cycle length (sec)</label><small>Time between changes</small></div><input id="settingCycleLen" type="number" min="1" value="15" /></div>
    <div class="setting-row"><div class="icon"><i class="fa-solid fa-dice"></i></div><div><label for="settingRandom">Random order</label><small>Shuffle presets instead of linear</small></div><input id="settingRandom" type="checkbox" checked /></div>

    <div class="divider"></div>
    <div class="row">
      <label for="settingBackend">Backend</label>
      <select id="settingBackend">
        <option value="auto">Auto</option>
        <option value="webgl2">WebGL2</option>
        <option value="webgpu">WebGPU (experimental)</option>
      </select>
    </div>
    <div class="row"><label for="settingDirect">Direct draw</label><input id="settingDirect" type="checkbox" /></div>
    <div class="row"><label for="settingAudioMode">Audio mode</label>
      <select id="settingAudioMode">
        <option value="internal">Internal</option>
        <option value="mic">Mic</option>
        <option value="both">Both</option>
      </select>
    </div>
    <div class="row"><label for="settingInternalMethod">Internal source</label>
      <select id="settingInternalMethod">
        <option value="auto">Auto</option>
        <option value="element">HTMLAudio</option>
        <option value="file">Local File</option>
        <option value="tab">Tab Capture</option>
      </select>
    </div>
    <div class="row"><label>Monitor audio</label><input id="settingMonitor" type="checkbox" checked /></div>

    <div class="row"><label>Particles</label><input id="settingParticles" type="checkbox" /></div>
    <div class="row advanced"><label>Count</label><input id="settingParticleCount" type="number" min="0" max="5000" step="50" value="600" /></div>

    <div class="row"><label>Model Effects</label><input id="settingModelEffects" type="checkbox" /></div>
    <div class="row"><label>Model Only</label><input id="settingModelOnly" type="checkbox" /></div>

    <div class="row"><label>Reduce motion</label><input id="settingReduceMotion" type="checkbox" /></div>
  </div>

  <div id="playlistPanel">
    <h4>Presets</h4>
    <ul id="presetList"></ul>
  </div>

  <div id="busy" role="alert" aria-live="polite" aria-hidden="true">
    <div class="busy-card">
      <div class="spinner"></div>
      <div class="busy-label">Working…</div>
    </div>
  </div>

  <div id="toast" role="status" aria-live="polite"></div>
  <div id="live" class="sr-only" aria-live="polite" style="position:absolute;left:-9999px;top:auto;width:1px;height:1px;overflow:hidden;">Ready</div>

  <!-- Packs Modal -->
  <div id="packsModal" class="modal" aria-hidden="true">
    <div class="modal-card">
      <h3>Preset Packs</h3>
      <div class="row"><label>Base</label><input id="packBase" type="checkbox" checked /></div>
      <div class="row"><label>Extra</label><input id="packExtra" type="checkbox" checked /></div>
      <div style="font-size:12px;opacity:.8;margin-top:6px;">Toggle which preset packs are available in the playlist.</div>
      <div class="modal-actions">
        <button class="btn" onclick="document.getElementById('packsModal').classList.remove('open')">Close</button>
      </div>
    </div>
  </div>

  <!-- About Modal -->
  <div id="aboutModal" class="modal" aria-hidden="true">
    <div class="modal-card">
      <h3>About Veed Sync</h3>
      <div style="font-size:14px;opacity:.92;line-height:1.5">
        Real‑time WebGL visualizer. Mic and local audio supported. Presets courtesy of the community.
      </div>
      <div style="margin-top:10px;">
        <span class="chip">GPU: <span id="aboutGpu">detecting…</span></span>
        <span class="chip">WebGPU: <span id="aboutWebgpu">checking…</span></span>
      </div>
      <div style="margin-top:10px;font-size:12px;opacity:.85;font-family: var(--font-mono);">
        Shortcuts: Space (Play/Pause), ←/→ (Prev/Next), F (Fullscreen), P (Presets), S (Settings), X (Disable), Esc (Close)
      </div>
      <div class="modal-actions">
        <button class="btn" onclick="document.getElementById('aboutModal').classList.remove('open')">Close</button>
      </div>
    </div>
  </div>

  <!-- Models Modal -->
  <div id="modelsModal" class="modal" aria-hidden="true">
    <div class="modal-card">
      <h3>Models</h3>
      <div class="row">
        <label for="modelsCategory">Category</label>
        <select id="modelsCategory" style="min-width: 180px;"></select>
      </div>
      <div class="row">
        <label for="modelsSample">Sample every (vertices)</label>
        <input id="modelsSample" type="number" min="1" max="16" step="1" value="3" />
      </div>
      <div class="row">
        <label for="modelsBlend">Blend time (sec)</label>
        <input id="modelsBlend" type="number" min="0" max="10" step="0.1" value="1.5" />
      </div>
      <div class="row">
        <label for="modelsPreload">Save as preload</label>
        <input id="modelsPreload" type="checkbox" />
      </div>
      <div id="modelsList" class="models-grid"></div>
      <div class="modal-actions">
        <button class="btn" onclick="document.getElementById('modelsModal').classList.remove('open')">Close</button>
      </div>
    </div>
  </div>
</body>


